<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《数值计算方法》课设-迭代法在数值计算方法中的运用]]></title>
    <url>%2F2018%2F06%2F15%2F%E3%80%8A%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BE%E8%AE%BE-%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%9C%A8%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[摘要 迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法(或者称为一次解法)，即一次性解决问题。迭代算法是用计算机解决问题的一种基本方法，它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令(或一定步骤)进行重复执行，在每次执行这组指令(或这些步骤)时，都从变量的原值推出它的一个新值，迭代法又分为精确迭代和近似迭代。比较典型的迭代法如“二分法”和”牛顿迭代法”属于近似迭代法。 在这篇文章里，主要介绍迭代法在线性方程组的数值解法和非线性方程组中迭代法运用，以及迭代法在数据结构算法中的优化和机器学习算法的运用。 关键词： Jacobi 迭代法 Gauss-Seidel 迭代法 Newton-Raphson 迭代法 工具&amp;语言：Matlab， C++ 1. 迭代法在线性方程组数值解法中的运用解线性方程组的迭代法是对任意给定的初始近似解向量，按着某种方法逐步生成近似解序列，使解序列的极限为方程的解。因此迭代是利用某种极限过程去逐步逼近精确解的方法，从而可以利用有限步计算算出指定精度的近似解。迭代法主要有：Jacobi 迭代法、Gauss-Seidel 迭代法和超松弛迭代法。 1.1 迭代法的一般形式设有线性方程组 矩阵形式（1.1）： $$ Ax = b $$ 分量形式（1.2）： $$\begin{cases} a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1\\ a_{21}x_1&amp;+&amp;a_{22}x_2&amp;+&amp;\cdots&amp;+a_{2n}x_n&amp;=&amp;b_2\\ &amp;&amp;&amp;&amp;\vdots\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp; \end{cases}$$ 以矩阵形式进行阐述，其中$A$为非奇异矩阵，向量$b\neq0$，因而有唯一解$x^\ast$。下面介绍迭代法的一般形式。 先将方程组变形为等价的同解线性方程组（1.3） $$x = Bx + f$$ 的形式，然后任取一个初始向量$x^{(0)}\epsilon R^n$作为近似解，由公式（1.4） $$x^{(k+1)}=Bx^{(k)}+f, \quad k=0,1,2,\cdots$$ 构造向量序列$\lbrace x^{(k)}\rbrace$，如果向量序列$\lbrace x^{(k)}\rbrace$满足（1.5） $$\lim_{k \to +\infty} x^{(k)} = x^\ast$$ 则称迭代法收敛，$x^\ast$即是方程组（1.2）的解，否则，称迭代法发散。式（1.4）称为迭代形式，$B$为迭代矩阵，$x^{(k)}$为第$k$次迭代近似解，称$e^{(k)} = x^{*} + x^{(k)}$为第k次迭代误差。 1.2 Jacobi迭代法及算法实现 Jacobi迭代法的分量形式 设线性方程（1.1）的分量形式为（1.6） $$\begin{cases} a_{11}x_1&amp;+&amp;a_{12}x_2&amp;+&amp;\cdots&amp;+a_{1n}x_n&amp;=&amp;b_1\\ a_{21}x_1&amp;+&amp;a_{22}x_2&amp;+&amp;\cdots&amp;+a_{2n}x_n&amp;=&amp;b_2\\ &amp;&amp;&amp;&amp;\vdots\\ a_{n1}x_1&amp;+&amp;a_{n2}x_2&amp;+&amp;\cdots&amp;+a_{nn}x_n&amp;=&amp;b_n&amp; \end{cases}$$ Jacobi的迭代步骤： （1）设$a_{ii} \neq 0(i = 1,2,\cdots,n)$. 将线性方程组（1.6）的第$i$个方程中的第$i$个变元$x_{i}$用其他$n-1$个变元表示，即解出（1.7） $$\begin{cases} x_1=\frac{1}{a_{11}}(b_1&amp;-&amp;a_{12}x_2&amp;-&amp;a_{13}x_3&amp;-&amp;\cdots&amp;-&amp;a_{1n}x_n)&amp;\\ x_2=\frac{1}{a_{22}}(b_2&amp;-&amp;a_{21}x_1&amp;-&amp;a_{23}x_3&amp;-&amp;\cdots&amp;-&amp;a_{2n}x_n)&amp;\\ &amp;&amp;&amp;&amp;\vdots\\ x_n=\frac{1}{a_{nn}}(b_n&amp;-&amp;a_{n1}x_1&amp;-&amp;a_{n2}x_2&amp;-&amp;\cdots&amp;-&amp;a_{n,n-1}x_{n-1})&amp;\\ \end{cases}$$ 即（1.8） $$ x_i=\frac{b_i - \sum_{j=1,j \neq i}^n a_{ij}x_j}{a_{ii}}, \quad i = 1,2,\cdots,n. $$ (2)写成迭代形式（1.9） $$\begin{cases} x_1^{(k+1)}=\frac{1}{a_{11}}(b_1&amp;-&amp;a_{12}x_2^{(k)}&amp;-&amp;a_{13}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{1n}x_n^{(k)})&amp;\\ x_2^{(k+1)}=\frac{1}{a_{22}}(b_2&amp;-&amp;a_{21}x_1^{(k)}&amp;-&amp;a_{23}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{2n}x_n^{(k)})&amp;\\ &amp;&amp;&amp;&amp;\vdots\\ x_n^{(k+1)}=\frac{1}{a_{nn}}(b_n&amp;-&amp;a_{n1}x_1^{(k)}&amp;-&amp;a_{n2}x_2^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{n,n-1}x_{n-1}^{(k)})&amp;\\ \end{cases}$$ 即（1.10） $$ x_i^{(k+1)} = \frac{b_i - \sum_{j=1,j \neq i}^n a_{ij}x_j^{(k)}}{a_{ii}}, \quad i = 1,2,\cdots,n;k = 0,1,2,\cdots. $$ (3)取初值向量$x^{(0)} = (x_1^{(0)},x_2^{(0)},\cdots,x_n^{(0)})^T$代入（1.9），逐次算出向量序列$\lbrace x^{(k)}\rbrace (K=1,2,\cdots)$，这里$x^{(k)} = (x_1^{(k)},x_2^{(k)},\cdots,x_n^{(k)})^T$. 向量序列$\lbrace x^{(k)}\rbrace$收敛时，对于事先给定的精度要求$\epsilon$, 当 $$\mid\mid x^{(k+1}) - x^{(k)}\mid\mid_{\infty} &lt; \epsilon$$ 时，即得方程组的近似解$x^{*}\approx x^{(k+1)}$. Jacobi的矩阵形式 设线性方程组（1.1）的系数矩阵A非奇异，且主对角线元素$a_{ii}\neq 0(i=1,2,\cdots,n)$，将矩阵A分解为（1.11） $$ A = \begin{pmatrix} 0 \\ a_{21} &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots \\ a_{n1} &amp; a_{n2} &amp; \cdots &amp; 0 \\ \end{pmatrix} + \begin{pmatrix} a_{11} \\ &amp; a_{22} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; a_{nn} \\ \end{pmatrix} + \begin{pmatrix} 0 &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ &amp; 0 &amp; \cdots &amp; a_{2n} \\ &amp; &amp; \ddots &amp; \vdots \\ &amp; &amp; &amp; 0 \\ \end{pmatrix} $$ 记作 $$A = L + D + U$$ 则$Ax=b$等价于 $$(L+D+U)x = b$$ 即 $$Dx = -(L+U)x + b$$ 由$a_{ii}\neq 0(i=1,2,\cdots,n)$，则 $$x = -D^{-1}(L+U)x + D^{-1}b$$ 得迭代格式（1.12）： $$x^{(K+1)} = -D^{-1}(L+U)x^{k} + D^{-1}b$$ 令 $$B=-D^{-1}(L+U);f=D^{-1}b$$ 则有（1.13） $$x^{(k+1)}= Bx^{(k)}+f$$ 称式（1.13）为Jacobi迭代式得矩阵形式，其中$B$称为Jacobi迭代矩阵，Jacobi迭代法的矩阵形式，主要用来讨论其收敛性，实际计算中，常用分量形式。 Jacobi迭代法的MATLAB程序 (1). 分量形式 1234567891011121314151617181920212223242526function [x,k] = jacobif(A,b,x0,ep,Nmax)% 用分量形式jacobi迭代法解线性方程组Ax=b% [x,k]=jacobif(A,b,x0,ep,Nmax),A为系数矩阵，b为右端向量，x为返回解向量% x0为迭代初值（默认值为原点），ep为精度（默认值为1e-5）% k为迭代次数上限以防法发散（默认值为500）n=length(A);k=0;if nargin&lt;5 Nmax=500;endif nargin&lt;4 ep=1e-5;endif nargin&lt;3 x0=zeros(n,1);y=zeros(n,1);endx=x0;x0=x+2*ep;while norm(x0-x,inf)&gt;ep&amp;&amp;k&lt;Nmax,k=k+1;x0=x; for i=1:n y(i)=b(i); for j=1:n if j~=i y(i)=y(i)-A(i,j)*x0(j); end end if abs(A(i,i))&lt;1e-10||k==Nmax warning('A(i,i) is small'); return end y(i)=y(i)/A(i,i); end x=y;end （2）矩阵形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344% 雅可比迭代法，计算线性方程组的解function [x,k] = jacobi_iteration(A,b,x0,tol)% tol为输入误差容限，x0为迭代初始值% 默认最多迭代300次，超出300次会给出警示max1 = 300; %求A的对角矩阵D = diag(diag(A));%求A的下三角矩阵%% 虽然查MATLAB的文档里tril和triu没有什么区别，但是实际写代码的时候%% 还是会有差别的，总之记住这应上三角和下三角的表示方法就好了%%% 这里加负号的原因是由雅可比迭代的原理可知的，需要下三角矩阵的每个元素取负%%% 下面的U也是同样的道理L = -tril(A,-1);%求A的上三角矩阵U = -triu(A,1);% \表示对D求逆之后乘以（L+U）和bB = D\(L+U);f = D\b;x = B*x0+f;k = 1;% norm是取二范数的意思while norm(x-x0)&gt;=tol x0 = x; x = B*x0+f; k = k+1; if(k&gt;=max1) % 输出内容的函数 disp('迭代次数超过',max1,'次，方程组可能不收敛'); %% 在MATLAB中遇到return的意思就是结束整个函数的执行， %% break是仅仅跳出循环体 return; end %该命令的作用是显示每一步的迭代结果,注意x是列向量，’表示转置的意思，所以要加’ [k,x']end jacobi迭代法的C++程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*雅可比算法的代码实现*/ #include&lt;iostream&gt; #include&lt;iomanip&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; //函数求数组中的最大值 double MaxOfList(vector&lt;double&gt;x)&#123; double max=x[0]; int n=x.size(); for(int i=0;i&lt;n;i++) if(x[i]&gt;max) max=x[i]; return max; &#125; //雅可比迭代公式 void Jacobi(vector&lt;vector&lt;double&gt; &gt; A,vector&lt;double&gt; B,int n)&#123; vector&lt;double&gt; X(n,0); vector&lt;double&gt; Y(n,0); vector&lt;double&gt; D(n,0); int k=0; //记录循环次数 do&#123; X=Y; for(int i=0;i&lt;n;i++)&#123; double tem=0; for(int j=0;j&lt;n;j++)&#123; if(i!=j) tem += A[i][j]*X[j]; &#125; Y[i]=(B[i]-tem)/A[i][i]; cout&lt;&lt;left&lt;&lt;setw(8)&lt;&lt;Y[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; k++; if(k&gt;100)&#123; cout&lt;&lt;"迭代失败！（可能是函数不收敛）"&lt;&lt;endl; return ; &#125; for(int a=0;a&lt;n;a++)&#123; D[a]=X[a]-Y[a]; &#125; &#125;while( MaxOfList(D)&gt;0.00001 || MaxOfList(D)&lt;-0.00001); return ; &#125; int main()&#123; int n; cout&lt;&lt;"请输入方程组未知数的个数n："; cin&gt;&gt;n; cout&lt;&lt;endl; vector&lt;vector&lt;double&gt; &gt;A(n,vector&lt;double&gt;(n,0)); vector&lt;double&gt;B(n,0); cout&lt;&lt;"请输入方程组的系数矩阵："&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cin&gt;&gt;A[i][j]; &#125; &#125; cout&lt;&lt;endl; cout&lt;&lt;"请输入方程组的值向量："&lt;&lt;endl; for(int k=0;k&lt;n;k++)&#123; cin&gt;&gt;B[k]; &#125; cout&lt;&lt;endl; cout&lt;&lt;"您输入的方程组为："&lt;&lt;endl; for(int a=0;a&lt;n;a++)&#123; for(int b=0;b&lt;n;b++)&#123; cout&lt;&lt;A[a][b]&lt;&lt;" "; &#125; cout&lt;&lt;" "&lt;&lt;B[a]&lt;&lt;endl; &#125; cout&lt;&lt;endl; cout&lt;&lt;"由雅可比迭代公式求的方程组的解为："&lt;&lt;endl; Jacobi(A,B,n); //getch(); system("pause"); return 0; &#125; 例1. 用jacobi迭代法解线性方程组 $$ \begin{pmatrix} 4 &amp; 3 &amp; 0 \\ 3 &amp; 4 &amp; -1 \\ 0 &amp; -1 &amp; 4 \\ \end{pmatrix} \begin{pmatrix} x_1 \\ x_2 \\ x_3 \\ \end{pmatrix} = \begin{pmatrix} 24 \\ 40 \\ -24 \\ \end{pmatrix} $$ 使用MATLAB（Jacobi迭代法分量形式）解决该问题 在MATLAB中输入： 123A=[4 3 0;3 4 -1;0 -1 4];b=[24 30 -24]';[x,k]=jacobif(A,b) 得到： 使用c++解决该问题 1.3 Gauss-Seidel迭代法以及算法实现Gauss-Seidel迭代法就是对Jacobi迭代法的一种算法上的优化，让第$i$行的方程都能用上前$i-1$行得出的结果。以$1$和$2$两式对比，更容易看出Gauss-Seidel迭代法的改动优化。 Jacobi迭代法的分量形式 $$\begin{cases} x_1^{(k+1)}=\frac{1}{a_{11}}(b_1&amp;-&amp;a_{12}x_2^{(k)}&amp;-&amp;a_{13}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{1n}x_n^{(k)})&amp;\\ x_2^{(k+1)}=\frac{1}{a_{22}}(b_2&amp;-&amp;a_{21}x_1^{(k)}&amp;-&amp;a_{23}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{2n}x_n^{(k)})&amp;\\ &amp;&amp;&amp;&amp;\vdots\\ x_n^{(k+1)}=\frac{1}{a_{nn}}(b_n&amp;-&amp;a_{n1}x_1^{(k)}&amp;-&amp;a_{n2}x_2^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{n,n-1}x_{n-1}^{(k)})&amp;\\ \end{cases}$$ 即（1.10） $$ x_i^{(k+1)} = \frac{b_i - \sum_{j=1,j \neq i}^n a_{ij}x_j^{(k)}}{a_{ii}}, \quad i = 1,2,\cdots,n;k = 0,1,2,\cdots. $$ Gauss-Seidel迭代法的分量形式 $$\begin{cases} x_1^{(k+1)}=\frac{1}{a_{11}}(b_1&amp;-&amp;a_{12}x_2^{(k)}&amp;-&amp;a_{13}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{1n}x_n^{(k)})&amp;\\ x_2^{(k+1)}=\frac{1}{a_{22}}(b_2&amp;-&amp;a_{21}x_1^{(k+1)}&amp;-&amp;a_{23}x_3^{(k)}&amp;-&amp;\cdots&amp;-&amp;a_{2n}x_n^{(k)})&amp;\\ &amp;&amp;&amp;&amp;\vdots\\ x_n^{(k+1)}=\frac{1}{a_{nn}}(b_n&amp;-&amp;a_{n1}x_1^{(k+1)}&amp;-&amp;a_{n2}x_2^{(k+1)}&amp;-&amp;\cdots&amp;-&amp;a_{n,n-1}x_{n-1}^{(k+1)})&amp;\\ \end{cases}$$ 即（1.10） $$ x_i^{(k+1)} = -\frac{1}{a_{ii}}\sum_{j=1}^{i-1}a_{ij}x_{j}^{k+1}-\frac{1}{a_{ii}}\sum_{j=i+1}^{n}a_{ij}x_{j}^{k}+\frac{1}{a_{ii}}b_i, \quad (i = 2,3,\cdots,n-1) $$ Gauss-Seidel迭代法的MATLAB实现（矩阵形式） 12345678910111213141516171819202122232425262728293031323334353637%高斯-赛德尔迭代法，计算线性方程组的解function [x,k] = Gauss_Seidel_interation(A,b,x0,tol)% tol为输入误差容限，x0为迭代初始值% 默认最多迭代300次，超出300次会给出警示max1 = 300;%% diag(diag(X))%% 取出X矩阵的对角元，然后构建一个以X对角元为对角的对角矩阵。D = diag(diag(A));%求A的下三角矩阵,对角线元素为0，再每个矩阵元素取负号L = -tril(A,-1);%求A的上三角矩阵，对角线元素为0，再每个矩阵元素取负号U = -triu(A,1);% \表示对(D-L)求逆G = (D-L)\U;f = (D-L)\b;x = G*x0+f;k = 1;while norm(x-x0)&gt;=tol x0 = x; x = G*x0+f; k = k+1; if (k&gt;=max1) disp('迭代次数超过',max1,'次，方程组可能不收敛'); %% 在MATLAB中遇到return的意思就是结束整个函数的执行， %% break是仅仅跳出循环体 return; end %该命令的作用是显示每一步的迭代结果,注意x是列向量，’表示转置的意思，所以要加’ [k,x']end Gauss-Seidel迭代法的C++实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;iomanip&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; void Gauss_Seidel(vector&lt;vector&lt;double&gt; &gt; A,vector&lt;double&gt; B,int n) &#123; double X[n]=&#123;0,0,0,&#125;; for (int k=0;k&lt;1000;k++) &#123; for(int i=0;i&lt;n;i++) &#123; double sum=0; for(int j=0;j&lt;n;j++) &#123; if(j==i) continue; //跳过aii sum+=A[i][j]*X[j]; &#125; X[i]=(B[i]-sum)/A[i][i]; ///计算完新的x[i],旧的x[i]会被自然冲掉 &#125; &#125; for (int i=0;i&lt;n;i++) cout&lt;&lt;"x"&lt;&lt;i+1&lt;&lt;" = "&lt;&lt;X[i]&lt;&lt;'\n'; cout&lt;&lt;endl; &#125;int main() &#123; int n; cout&lt;&lt;"请输入方程组未知数的个数n："; cin&gt;&gt;n; cout&lt;&lt;endl; vector&lt;vector&lt;double&gt; &gt;A(n,vector&lt;double&gt;(n,0)); vector&lt;double&gt;B(n,0); cout&lt;&lt;"请输入方程组的系数矩阵："&lt;&lt;endl; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cin&gt;&gt;A[i][j]; &#125; &#125; cout&lt;&lt;endl; cout&lt;&lt;"请输入方程组的值向量："&lt;&lt;endl; for(int k=0;k&lt;n;k++)&#123; cin&gt;&gt;B[k]; &#125; cout&lt;&lt;endl; cout&lt;&lt;"您输入的方程组为："&lt;&lt;endl; for(int a=0;a&lt;n;a++)&#123; for(int b=0;b&lt;n;b++)&#123; cout&lt;&lt;A[a][b]&lt;&lt;" "; &#125; cout&lt;&lt;" = "&lt;&lt;B[a]&lt;&lt;endl; &#125; cout&lt;&lt;endl; cout&lt;&lt;"由雅可比迭代公式求的方程组的解为："&lt;&lt;endl; Gauss_Seidel(A,B,n); system("pause"); return 0;&#125; 例2. 用 Gauss-Seidel迭代法解线性方程组 $$ \begin{pmatrix} 8 &amp; -3 &amp; 2 \\ 4 &amp; 11 &amp; -1 \\ 2 &amp; 1 &amp; 4 \\ \end{pmatrix} \begin{pmatrix} x_1 \\ x_2 \\ x_3 \\ \end{pmatrix} = \begin{pmatrix} 20 \\ 33 \\ 12 \\ \end{pmatrix} $$ 1. 使用matlab（Gauss-Seidel迭代法矩阵形式）解决该问题 在matlab中输入： 1234A = [8,-3,2;4,11,-1;2,1,4];b = [20,33,12]';x0 = [0,0,0]';[x,k] = Gauss_Seidel(A,b,x0,1e-7) 得到： ![4](https://raw.githubusercontent.com/fuujiro/pictures/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/4.png) &lt;br&gt;&lt;/br&gt; 2. 使用c++解决该问题 ![5](https://raw.githubusercontent.com/fuujiro/pictures/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/5.png) 2. 迭代法在非线性方程组数值解法中的运用主要介绍牛顿迭代法（Newton-Raphson method）的实现和运用。 2.1 牛顿迭代法 牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。方法使用函数f(x)的泰勒级数的前面几项来寻找方程f(x) = 0的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程f(x) = 0的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。另外该方法广泛用于计算机编程中。 定义 设$r$是$f(x)=0$的根，选取$x_0$作为$r$的初始近似值，过点$(x_0,f(x_0))$做曲线$y=f(x)$的切线$L$，$L$的方程为$y=f(x_0)+f’(x_0)(x-x_0)$，求出$L$与$x$轴交点的横坐标$x_1=x_0-\frac{f(x_0)}{f’(x_0)}$，称$x_1$为$r$的一次近似值。过点$(x_1,f(x_1))$做曲线$y=f(x)$的切线，并求该切线与x轴交点的横坐标$x_2=x1-\frac{f(x_1)}{f’(x_1)}$，称$x_2$为$r$的二次近似值。重复以上过程，得r的近似值序列，其中，$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$称为$r$的$n+1$次近似值，上式称为牛顿迭代公式。 牛顿法求解非线性方程 用牛顿迭代法解非线性方程，是把非线性方程$f(x)=0$线性化的一种近似方法。把$f(x)$在点$x_0$的某邻域内展开成泰勒级数$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{f’’(x_0)(x-x_0)^2}{2!}+ \cdots + \frac{f^{(n)}(x-x_0)^n}{n!}+R_n(x)$，取其线性部分（即泰勒展开的前两项），并令其等于0，即$f(x_0)+f’(x_0)(x-x0)=0$，以此作为非线性方程$f(x)=0$的近似方程，若$f’(x_0)\neq 0$，则其解为$x_1=x_0-\frac{f(x_0)}{f’(x_0)}$，这样，得到牛顿迭代法的一个迭代关系式：$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$。 牛顿法的Matlab实现 123456789101112131415161718192021222324252627282930313233% fuujiro% 2018/6/15% 迭代参数x0 = -100; % 初始值err0 = inf; % 误差初始设为infiter = 0;% 迭代次数errMax = 1e-3; % 最大容许误差iterMax = 100; % 最大迭代次数% 迭代过程x(iter+1) = x0;while err0&gt;errMax % 迭代终止条件1：达到最大迭代次数 if iter == iterMax disp('达到最大迭代次数！'); break; end % Newton迭代过程 iter = iter+1; [~,dy,d2y] = func1(x(iter)); x(iter+1) = x(iter)-dy/d2y; % 迭代终止条件2：找到满足精度要求的解 if abs(x(iter+1)-x(iter))&lt;errMax disp('找到满足精度要求的解！') disp(['x = ',num2str(x(iter+1))]); disp(['迭代次数为',num2str(iter-1)]); break; endend% 迭代结果展示plot(x)xlabel('t');ylabel('x') 牛顿迭代法的C++实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double func(double x) //函数&#123; return x*x*x*x-3*x*x*x+1.5*x*x-4.0;&#125;double func1(double x) //导函数&#123; return 4*x*x*x-9*x*x+3*x;&#125;int Newton(double *x,double precision,int maxcyc) //maxcyc 迭代次数&#123; double x1,x0; int k; x0=*x; for(k=0;k&lt;maxcyc;k++) &#123; if(func1(x0)==0.0)//若通过初值，函数返回值为0 &#123; printf("迭代过程中导数为0!\n"); return 0; &#125; x1=x0-func(x0)/func1(x0);//进行牛顿迭代计算 if(fabs(x1-x0)&lt;precision || fabs(func(x1))&lt;precision) //达到结束条件 &#123; *x=x1; //返回结果 return 1; &#125; else //未达到结束条件 &#123; x0=x1; //准备下一次迭代 &#125; &#125; printf("迭代次数超过预期！\n"); //迭代次数达到，仍没有达到精度 return 0;&#125;int main()&#123; double x,precision; int maxcyc; printf("输入初始迭代值x0:"); scanf("%lf",&amp;x); printf("输入最大迭代次数："); scanf("%d",&amp;maxcyc); printf("迭代要求的精度："); scanf("%lf",&amp;precision); if(Newton(&amp;x,precision,maxcyc)==1) //若函数返回值为1 &#123; printf("该值附近的根为：%lf\n",x); &#125; else //若函数返回值为0 &#123; printf("迭代失败！\n"); &#125; system("pause"); return 0;&#125; 例3： 运行上方的C++代码，计算当初值取$5$时，求根。 结果： 3. 迭代法在实际生活中的运用在课程之外，我自身也参加了大学生创新创业项目计划，研究课题是机器人手臂视觉标定。简单阐述研究内容是，由于现阶段机器人的视觉标定算法有很多不同的方向和侧重，也有各自的不足，比如标定速度快慢，视觉信息处理速度，算法的时间空间复杂度等等。这些研究者提出的算法都很有创新性，但也会有某些方向的不足。 而我的研究方向，就是尽可能提高视觉标定的准确度，在准确度达标的情况下再尽可能优化标定速度。在前期，我使用的标定算法正巧就是数值计算方法中的牛顿迭代法，因为牛顿法的实现简单且普遍，标定结果也不差。 可能文字难以描述标定过程，放上前期答辩的材料帮助理解。 标定过程 编写代码处理双目深度相机Kinect采集到的数据 处理完数据后，在原始图像进行黑白格标定 逐步进行迭代法优化，处理结果从左图逐渐优化成右图 简而言之，迭代法在这次大学生创新项目的应用十分成功，我也顺利地通过了前期答辩，拿到了国家级大创项目的评级。 4. 课程感悟随着计算机和计算方法的飞速发展，几乎所有学科都走向定量化和精确化，从而产生了一系列计算性的学科分支，如计算物理、计算化学、计算生物学、计算地质学、计算气象学和计算材料学等，计算数学中的数值计算方法则是解决“计算”问题的桥梁和工具。 我已经深深地体会到了，计算能力是计算工具和计算方法的效率的乘积，提高计算方法的效率与提高计算机硬件的效率同样重要。科学计算已用到科学技术和社会生活的各个领域中。 数值分析的目的是设计及分析一些计算的方式，可针对一些问题得到近似但够精确的结果。因此在这次的课程设计中我阐述的是迭代法的应用。 迭代法是通过从一个初始估计出发寻找一系列近似解来解决问题的数学过程。和直接法不同，用迭代法求解问题时，其步骤没有固定的次数，而且只能求得问题的近似解，所找到的一系列近似解会收敛到问题的精确解。会利用审敛法来判别所得到的近似解是否会收敛。一般而言，即使使用无限精度算术的计算方式，迭代法也无法在有限次数内得到问题的精确解。 通过课程设计的构思到编写代码实现，我感觉自己对迭代法的理解愈来愈深，深感数学工具与计算数学发展相辅相成。非常感谢孙焘老师对于数值计算方法这门课的付出，希望自己能够踏实地在学习的大路上慢慢走下去。]]></content>
  </entry>
  <entry>
    <title><![CDATA[NJU-计算机系统基础笔记]]></title>
    <url>%2F2018%2F05%2F22%2FNJU-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言准备自学csapp了，怕听不懂课。知乎说NJU的袁春华老师讲的计算机系统基础特别好，所以准备先学这个好了。 1. 第一章1.1 理解 计算机系统抽象层，从上至下依次是：应用（问题），算法，编程（语言），操作系统/虚拟机，指令集体系结构（ISA），微体系结构，功能部件，电路，器件。指令集体系结构是软件和硬件的交界层。 1.2 程序开发和执行过程简介 指令包含操作码和操作数或其他地址码 机器语言和汇编语言都是面向机器结构的语言，统称为机器级语言 编译程序(Complier)：将高级语言源程序转换为机器级目 标程序，执行时只要启动目标程序即可 解释程序(Interpreter )：将高级语言语句逐条翻译成机器 指令并立即执行，不生成目标文 1.3 指令集体系结构 ISA(Instruction Set Architecture)，即指令集体系结构 ISA是一种规约 1.4 冯诺依曼体系结构 1946年，普林斯顿高等研究院（the Institute for Advance Study at Princeton，IAS ）开始设计 存储程序计算机，被称为IAS计算机（1951年才完成，并不是第一台存储程序计算机，1949年由英国剑桥大学完成的EDSAC是第一台）。在那个报告中提出的计算机结构被称为冯·诺依曼结构。冯·诺依曼结构最重要的思想是“存储程序(Stored-program)” 工作方式： 任何要计算机完成的工作都要先被编写成程序，然后将程序和原始 数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操 作人员干预下，自动完成逐条取出指令和执行指令的任务 冯诺依曼的主要思想： 计算机应由运算器、控制器、存储器、输入设备和输出设备 五个基本部件组成。 各基本部件的功能是： • 存储器不仅能存放数据，而且也能存放指令，形式上两者 没有区别，但计算机应能区分数据还是指令； • 控制器应能自动取出指令来执行； • 运算器应能进行加/减/乘/除四种基本算术运算，并且也 能进行一些逻辑运算和附加运算； • 操作人员可以通过输入设备、输出设备和主机进行通信。 内部以二进制表示指令和数据。每条指令由操作码和地址码 两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。 采用“存储程序”工作方式。 2. 第二章2.1 定点数的编码表示 模运算 结论1：一个负数的补码等于模减该负数的绝对值。 结论2：对于某一确定的模，某数减去小于模的另一数，总可 以用该数加上另一数负数的补码来代替。 补码的表示 结论1：一个负数的补码等于将对应正数补码 各位取反、末位加一 变形（4’s）补码：双符号，用于存放可能溢出的中间结果 求补码的真值： 简便求法： 符号为0，则为正数，数值部分相同 符号为1，则为负数，数值各位取反，末位加]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows和manjaro双系统共存引导的解决方法]]></title>
    <url>%2F2018%2F05%2F22%2FWindows%E5%92%8Cmanjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%85%B1%E5%AD%98%E5%BC%95%E5%AF%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 Q: What do the Ninja-fuujiro do?A: 简单来说，就是替换引导文件。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。 （为什么要替换？因为Manjaro太弱鸡，Windows是攻，我们帮Manjaro一把。我们是平权主义者！拒绝霸道2333！ε=ε=ε=┏(゜ロ゜;)┛ 1. 打开Windows Powershell(Administrator) win + x a 2. 将grubx64.efi 引导代替掉 bootmgfw.efi 输入 1bcdedit /set &apos;&#123;bootmgr&#125;&apos; path \EFI\Manjaro\grubx64.efi 如果不好意思，你的Powershell对你有意见。你可能需要把&#39;{bootmgr}&#39;换成{bootmgr}。原因是可能你没听话，用的是cmd，没见着我说用Powershell了嘛~！ 感谢 Linux 与 Windows 10 用 GRUB 引导教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[尝螃蟹的人，体验Ubuntu 18.04 LTS（仿生河狸）！]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%B0%9D%E8%9E%83%E8%9F%B9%E7%9A%84%E4%BA%BA%EF%BC%8C%E4%BD%93%E9%AA%8CUbuntu-18-04-LTS%EF%BC%88%E4%BB%BF%E7%94%9F%E6%B2%B3%E7%8B%B8%EF%BC%89%EF%BC%81%2F</url>
    <content type="text"><![CDATA[前言Ubuntu 18.04 LTS在2018年4月26号准时发布啦！！！当天我还是没挤进去成功下载，国内几大镜像源似乎都爆掉了，直到今天我才把Ubuntu 18.04装在虚拟机上体验了一把！感觉很棒哦，不错嘛~！ Ubuntu 18.04 LTS 被 Canonical 创始人 Mark Shuttleworth 命名为Bionic Beaver，仿生海狸，这主要是为了纪念 Ubuntu 人孜孜不倦的辛劳工作。所以，以海狸充满活力的态度，勤劳的本性，此次版本更新周期以这种哺乳动物作为吉祥物进行命名。 废话不多说，Ubuntu 18.04 LTS到底带给我们哪些new features呢？到底换不换发行版呢？让我们一起来看看！ 1. Ubuntu 18.04 LTS的闪光点1.1 GNOME正式抵达 我觉得太tm酷啦！！23333~ Ubuntu 18.04 LTS 发布的同时也带来了 GNOME 3.28，由于 GNOME 在 Ubuntu 17.10 中已经取代了 Unity（尽管 Unity 并未完全挂掉），因此 GNOME 也已经成为了 Ubuntu 系统默认的桌面环境。 当然，如果你不喜欢使用 GNOME，其他 Ubuntu 桌面环境也是可用的，如：MATE。 GNOME 正式来到 Ubuntu 18.04 LTS 桌面也标志着新统一风格定制的 GNOME 3.0 桌面在长期支持版本上得到支持，这也是升级到 Ubuntu 18.04 系统一个很好的理由。 1.2 全新的图标集 官方宣传图 实际图 1.3 彩色emoji 表情符号在个人 Linux 功能愿望清单中需求度可能不会很高，但不能否认表情符号现在是现代数字通信的一个重要组成部分。包括 Fedora 在内的许多其他流行 Linux 发行版很久以前就获得了对 emoji 的支持，在 Ubuntu 18.04 LTS 正式发布时，Ubuntu 用户也终于可以享受桌面应用程序中对彩色表情符号的开箱即用支持了。 为确保平台之间的一致性， Ubuntu 18.04 LTS 将使用 Noto Color Emoji 字体，该字体支持最新 Unicode 版本中定义的所有表情符号。 怎么安装新的emoji呢? 1sudo apt install fonts-emojione]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构-Review！]]></title>
    <url>%2F2018%2F04%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Review-%E8%80%83%E8%AF%95%E9%AB%98%E5%88%86%E8%BF%87%EF%BC%81%2F</url>
    <content type="text"><![CDATA[前言复习一下课没好好上过的数据结构，唉！要期末考试噜！数据结构和算法要是想成为Master，好难欸！！~ Q：如何高效率使用这篇总结？A：查看写的所有数据结构的定义，然后戳所有带-&gt; recommend！这个标识的链接，嗯！速度就是这样~认真的话，建议复写所有数据结构的实现代码啦！ 目录 线性表 1.1 顺序表示和实现 1.2 链式表示和实现 1.2.1 线性链表 1.2.2 循环链表 1.2.3 双向链表 栈和队列 2.1 栈 2.2 队列 数组 3.1 数组的顺序表示和实现 3.2 矩阵的压缩存储 3.2.1 稀疏矩阵 树 4.1 二叉树 4.2 遍历二叉树 4.2.1 三大遍历的递归实现 4.2.2 三大遍历的非递归实现 4.2.3 层次遍历 4.3 树和森林 4.3.1 数和森林的存储结构 4.3.2 数和森林的遍历 4.4 赫夫曼树 图 5.1 图的定义 5.2 图的存储结构 5.2.1 邻接表 5.2.2 十字链表 5.3 图的遍历 5.3.1 深度优先搜索 5.3.2 广度优先搜索 5.4 图的连通性 5.4.1 最小生成树 5.5 拓扑排序 5.6 最短路径 5.6.1 Dijkstra算法 查找 6.1 静态查找 6.1.1 顺序查找 6.1.2 二分查找 6.2 动态查找 6.2.1 二叉排序树 6.3 哈希表 内部排序 7.1 插入排序 7.1.1 直接插入排序 7.1.2 折半插入排序 7.1.3 希尔排序 7.2 交换排序 7.2.1 冒泡排序 7.2.2 快速排序 7.3 选择排序 7.3.1 简单选择排序 7.3.2 堆排序 7.4 归并排序 1. 线性表 线性表Linear_list是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。 1.1 顺序表示和实现 线性表的顺序表示Sequential List指的是用一组地址连续的储存单元依次储存线性表的数据元素。顺序储存结构是一种随机存取的储存结构。通常用数组来描述顺序储存结构。 C语言用动态分配的一维数组，来描述线性表： 12345678 #define LIST_INIT_SIZE 100 //线性表储存空间的初始分配量 #define LISTINCREMENT 10 //线性表的分配量typedef int ElemType;typedef struct &#123; ElemType *elem; // 储存空间的基地址 int length; //当前线性表的长度 int listsize; //当前分配的储存容量&#125;SqList; 更多有关线性表的知识，请戳： 线性表与13个基本操作的实现 1.2 链式表示和实现 链式储存结构Linked List与顺序储存结构Sequential List的不同：顺序储存结构的特点是逻辑关系上两个相邻元素在物理位置上也相同，这样随机存取任意元素很快很直观，缺点是需要移动大量其他元素。而链式结构，它不要求逻辑上相邻的元素在物理位置上相邻，因此它存取元素不需要移动其他元素，但是对于查找元素有心无力。 1.2.1 线性链表 可以理解为单向链表Singly Linked List，单向链表是非随机存取结构。 一些常用的方法： 添加元素（s是指向待添加节点的指针） 12s-&gt;next = p-&gt;next;p-&gt;next = s; 删除元素（a,b,c是链表中相连的3个结点，b是待删除的结点，现在p是指向a结点的指针） 1p-&gt;next = p-&gt;next-&gt;next; 用结构体实现链表结点： 12345//线性表的单链表储存结构struct Node &#123; int data; //数据域 struct Node *next; //指针域&#125;; 更多链表知识，请戳： C语言单向链表的实现 链表的基本使用一（构建链表） 数据结构：链表(linked-list) 1.2.2 循环链表 循环单链表特点： 链表中最后一个结点的指针域不再是结束标志，而是指向整个链表的第一个结点，从而使链表形成一个环。和单链表相同，循环单链表也有带头结点和不带头结点两种。带头结点的循环单链表实现插入和删除操作较为方便，且更加适用。 单链表与循环单链表比较： 循环单链表可以从尾到头，而单链表不能从尾到头。因此处理的数据序列具有环形结构特点时，适合采用循环单链表。 带头结点的循环单链表和带头结点的单链表比较： ① 在初始化函数中，把语句head-&gt;next=NULL改为head-&gt;next = head，即形成一个环 ② 在其他函数中，循环判断条件p-&gt;next!=NULL和p-&gt;next-&gt;next!=NULL中的NULL改成头指针head。 1.2.3 双向链表 双向链表特点： 每个节点除了有后继指针域还有一个前驱指针域。 双向链表的分类： 双向链表有：带头结点和不带头结点的双向链表（但是带头结点的双向链表更为常用）。也有循环和非循环之分，循环结构的双向链表更为常用。因此下面讨论的是带头结点的循环双链表。 双向循环链表结点的结构体定义 123456//线性表的双向链表储存结构struct DuLNode &#123; Elemtype data; //数据域 struct DuLNode *prior; //前驱结点 struct DuLNode *next; //后继结点&#125;DuLNode， *DuLinklist; 备注：data域、next域、prior域。其中data域是数据域，next域为指向后继结点的指针域，prior域为指向前驱结点的指针域。 双向链表的优点： 在单链中查找当前结点的后继结点并不困难，可以通过当前结点的next指针进行，但要查找当前结点的前驱结点，就要从头指针head开始重新进行。对于一个要频繁进行当前结点的后继结点和前驱结点的应用来说，使用双向链表很有效。 双向循环链表的实现 在双向链表中，有如下指针关系：设指针p指向双向循环链表中的第i个位置，则p-&gt;next指向i+1个结点。p-&gt;next-&gt;prior仍指向第i个结点，即p-&gt;next-&gt;prior==p;同样p-&gt;prior指向第i-1个结点，p-&gt;prior-&gt;next仍指向第i个结点，即p-&gt;prior-&gt;next==p;双向循环链表关系算法可以方便算法设计。 更多循环链表和双向链表的知识，请戳： 数据结构——循环单链表和双向链表 数据结构 | 双向链表简单实现及图示 -&gt; recommend！ 2. 栈和队列 从数据结构上看，栈和队列也是线性表。不过他们是操作受限的线性表，因此，称它们为限定性的数据结构。 2.1 栈 栈stack是限定仅在表尾进行插入和删除的线性表。对于栈，表尾称为栈顶，相应地，表头称为栈底。不含元素的空表称为空栈。栈是一种后进先出（last in first out, LIFO）结构。 栈有两种储存方式，顺序栈和链式栈。 顺序栈的定义： 12345struct stack &#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack; 备注：stacksize指当前可使用的最大容量，base表示栈底指针，base为NULL时，表明栈结构不存在，其初值指向栈底，即top = base可作为栈空的标记。插入元素，top+1；删除元素，top-1。 更多栈的知识，请戳： [数据结构]C语言栈的实现 数据结构图文解析之：栈的简介及C++模板实现 -&gt; recommend！ 2.2 队列 和栈相反，队列quene是一种先进先出（first in first out, FIFO）的线性表，它只允许在表的一端插入，另一端删除。在队列中，允许插入的一端叫做队尾rear，允许删除的一端叫做队头front。 队列也有两种储存方式，顺序队列和链队列。 链队列的实现： 12345678struct QNode &#123; QElemType data; struct QNode *next;&#125;QNode, *QuenePtr;struct LinkQuene &#123; QuenePtr front; //队头指针 QuenePtr rear; //队尾指针&#125;LinkQuene; 更多队列知识，请戳： 数据结构-队列(queue) -&gt; recommend！ 3. 数组 数组和广义表可以看作是线性表的扩展，也算是一种数据结构。 3.1 数组的顺序表示和实现 由于数组一般不做插入或删除操作，因此采用顺序储存结构表示数组是最吼滴！ 假设每个数据元素占$L$个存储单元，则二维数组$A$中任一元素$aij$的存储位置可由下式确定：$LOC(i, j) = LOC(0, 0) + (b_2*i + j)L$ 数组的顺序存储的表示： 1234567 #define MAX_ARRAY_DIM 8struct array &#123; ElemType *base; int dim; int *bounds; int *constants;&#125;Array; 3.2 矩阵的压缩存储 压缩存储指的是为多个值相同的元只分配一个存储单元；对零元不分配空间。 更多压缩存储的知识，请戳： 对称矩阵的压缩 3.2.1 稀疏矩阵 对于那些零元素数目远远多于非零元素数目，并且非零元素的分布没有规律的矩阵称为稀疏矩阵（sparse）。 由于非零元素分布没有任何规律，所以在进行压缩存储的时侯需要存储非零元素值的同时还要存储非零元素在矩阵中的位置，即非零元素所在的行号和列号，也就是在存储某个元素比如$aij$的值的同时，还需要存储该元素所在的行号$i$和它的列号$j$，这样就构成了一个三元组$(i,j,aij)$的线性表。 123456789 #define MAXSIZE 12500struct triple &#123; int i, j; // 该非零元的行下标和列下标 ElemType e;&#125;Triple;struct tsmatrix &#123; Triple data[MAXSIZE + 1]; //非零元三元组 int mu, nu, tu; //行数，列数，非零元个数&#125;TSMatrix; 更多稀疏矩阵的知识，请戳： 稀疏矩阵 4. 树 树状图是一种数据结构，它是由$n$（$n&gt;=1$）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点（除了根节点外，每个子节点可以分为多个不相交的子树） 4.1 二叉树 二叉树Binary Tree是另一种树型结构，它的特点是每个结点至多有$2$棵子树（即二叉树中不存在度大于$2$的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树的性质： 在二叉树的第$i$层上至多有$2^(i-1)$个结点（$i&gt;=1$）。 深度为$k$的二叉树至多有$2^k - 1$个结点（$K&gt;=1$）。 对任何一棵二叉树$T$，如果其终端结点数为$n_0$，度为$2$的结点树为$n_2$，则$n_0=n_2+1$。 具有$n$个结点的完全二叉树的深度为|$\log_2 n$| + 1。（|$\log_2 n$|表示不大于$\log_2 n$的最大整数） 如果对一棵有$n$个结点的完全二叉树（其深度为|$\log_2 n$| + 1）的结点按层序编号（从第$1$层到第|$\log_2 n$| + $1$层，每层从左到右），则对任一结点$i$（$1 &lt;= i &lt;= n$），有： 如果$i = 1$，则结点$i$是二叉树的根，无双亲；如果$i &gt; 1$，则其双亲PARENT(i)是结点|$i/2$|。 如果$2i &gt; n$，则结点$i$无左孩子（即结点i为叶子结点）；否则其左孩子LCHILD(i)是结点$2$。 如果$2i + 1 &gt; n$，则结点$i$无右孩子；否则其右孩子RCHILD(i)是结点$2i+1$。 二叉树的顺序储存结构（仅适用于完全二叉树）： 123# define MAX_TREE_SIZE 100 // 二叉树的最大结点树typedef TElemType SqBiTree[MAX_TREE_SIZE]; // 0号单元存储根节点SqBiTree bt; 二叉树的链式存储结构： 1234struct BiTree &#123; TElemType data; // 数据域 struct BiTree *lchild, *rchild; // 左右孩子指针&#125;BiTree, *BiTree; 更多二叉树知识，请戳： 二叉树总结(一)概念和性质 markdown中的数学公式简要 4.2 遍历二叉树 二叉树是一种非线性结构，是由3个基本单元组成：根节点，左子树和右子树。规定先左后右，有3种基本情况，先序遍历，中序遍历和后序遍历。 4.2.1 三大遍历的递归实现 先序遍历（根-左-右） 1234567891011void preOrder1(BinaryTreeNode* pRoot) &#123; if(pRoot==NULL) return; cout&lt;&lt;pRoot-&gt;value; if(pRoot-&gt;left!=NULL) preOrder1(pRoot-&gt;left); if(pRoot-&gt;right!=NULL) preOrder1(pRoot-&gt;right); &#125; 中序遍历（左-根-右） 1234567891011void inOrder1(BinaryTreeNode* pRoot) &#123; if(pRoot==NULL) return; if(pRoot-&gt;left!=NULL) inOrder1(pRoot-&gt;left); cout&lt;&lt;pRoot-&gt;value; if(pRoot-&gt;right!=NULL) inOrder1(pRoot-&gt;right); &#125; 后序遍历（左-右-根） 12345678void postOrder1(BinaryTreeNode* pRoot) &#123; if(pRoot==NULL) return; postOrder1(pRoot-&gt;left); postOrder1(pRoot-&gt;right); cout&lt;&lt;pRoot-&gt;value&lt;&lt;" "; &#125; 4.2.2 三大遍历的非遍历实现 先序遍历（根-左-右） 1234567891011121314151617181920212223void preOrder2(BinaryTreeNode* pRoot) &#123; stack&lt;BinaryTreeNode*&gt; s; BinaryTreeNode *p=pRoot; if(pRoot==NULL) return; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;value&lt;&lt;" "; s.push(p); p=p-&gt;left; &#125; if(!s.empty()) &#123; p=s.top(); s.pop(); p=p-&gt;right; &#125; &#125; &#125; 中序遍历（左-根-右） 1234567891011121314151617181920void inOrder(BinaryTreeNode* pRoot) &#123; stack&lt;BinaryTreeNode*&gt; s; BinaryTreeNode *p=pRoot; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) &#123; s.push(p); p=p-&gt;left; &#125; if(!s.empty()) &#123; p=s.top(); cout&lt;&lt;p-&gt;value; s.pop(); p=p-&gt;right; &#125; &#125; &#125; 后序遍历（左-右-根） 12345678910111213141516171819202122232425void postOrder(BinaryTreeNode* pRoot) &#123; stack&lt;BinaryTreeNode*&gt; s; BinaryTreeNode *cur; BinaryTreeNode *pre=NULL; s.push(pRoot);//根结点入栈 while(!s.empty()) &#123; cur=s.top(); if((cur-&gt;left==NULL&amp;&amp;cur-&gt;right==NULL)||(pre!=NULL&amp;&amp;(pre==cur-&gt;left||pre==cur-&gt;right))) &#123; //左孩子和右孩子同时为空，或者当前结点的左孩子或右孩子已经遍历过了 cout&lt;&lt;cur-&gt;value&lt;&lt;" "; s.pop(); pre=cur; &#125; else &#123; if(cur-&gt;right!=NULL) s.push(cur-&gt;right); if(cur-&gt;left!=NULL) s.push(cur-&gt;left); &#125; &#125; &#125; 4.2.3 层次遍历 1234567891011121314151617181920212223void PrintFromTopToBottom(BinaryTreeNode* pRoot) &#123; if(pRoot == NULL) return; std::deque&lt;BinaryTreeNode *&gt; dequeTreeNode; dequeTreeNode.push_back(pRoot); while(dequeTreeNode.size()) &#123; BinaryTreeNode *pNode = dequeTreeNode.front(); dequeTreeNode.pop_front(); printf("%d ", pNode-&gt;m_nValue); if(pNode-&gt;m_pLeft) dequeTreeNode.push_back(pNode-&gt;m_pLeft); if(pNode-&gt;m_pRight) dequeTreeNode.push_back(pNode-&gt;m_pRight); &#125; &#125; 更多二叉树的知识，请戳： 二叉树的四种遍历的递归和非递归的实现 -&gt; recommend！ 二叉树三种遍历方式的递归和循环实现 4.3 树和森林 4.3.1 树的存储结构 双亲表示法 123456789 #define MAX_TREE_SIZE 100typedef struct PTNode &#123; // 结点结构 TElemType data; // 数据域 int parent; // 双亲位置域&#125;PTNode;typedef struct &#123; // 树结构 PTNode nodes[MAX_TREE_SIZE]; int r, n; // 根的位置和结点数&#125; 缺点：求结点的孩子时需要遍历整个结构。 孩子表示法 123456789101112typedef struct CTNode &#123; // 孩子结点 int child; sturct CTNode *next;&#125;*ChildPtr;typedef struct &#123; TElemType data; ChildPtr firstchild; // 孩子链表头结点&#125;CTBox;typedef struct &#123; CTBox nodes[MAX_TREE_SIZE]; int n, r; // 结点数的根的位置&#125; 孩子兄弟表示法（可以把复杂的树变成二叉树） 1234typedef struct CSNode &#123; ElemType data; struct CSNode *firstchild, *nextsibling; // 第一个孩子结点和下一个兄弟结点&#125; 4.3.2 树和森林的遍历 当二叉链表作为树的储存结构时，树的先根遍历和后根遍历类似于二叉树的先序遍历和中序遍历实现。 森林一般只说先序遍历和中序遍历，和二叉树的先序遍历和中序遍历相同。 更多树和森林的知识，请戳： 树的存储结构和代码实现 树和森林的遍历 4.4 赫夫曼树 赫夫曼树Huffman，又称最优二叉树，是一类带权路径长度最短的树。树的路径长度为树中所有叶子结点的带权路径长度之和。通常记作$WPL=\sum_{k=0}^{n}\omega_k\iota_k$ 。 假设有n个权值，构造一棵有n个叶子结点的二叉树，每个叶子结点带权为$\omega_i$，则其中带权路径长度$WPL$最小的二叉树称为赫夫曼树。 1234typedef struct &#123; unsigned int weight; // 权重 unsigned int parent, lchild, rchild; &#125;HTNode, *HuffmanTree; // 动态分配数组存储赫夫曼树 更多赫夫曼树的知识，请戳： 哈夫曼树 基础数据结构-二叉树-赫夫曼树的解码 5. 图 图Graph是一种较线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层的多个元素（即孩子结点）相关，但只和上一层的一个元素（即双亲结点）相关。而在图形结构中，结点之间的关系是任意的。 5.1 图的定义 在图中，数据元素称为顶点，$V$是顶点的有穷非空集合；$VR$是两个顶点之间的关系集合。 若$&lt;v,w&gt;\epsilon VR$,则$&lt;v,w&gt;$表示从$v$到$w$的一条弧Arc，且称$v$为弧尾Tailor初始点，$w$为弧头Heador终端点。此时的图称为有向图Digraph。 $$G_1 = (V_1,{A_1})$$ 若$&lt;v,w&gt;\epsilon VR$，必有$&lt;w,v&gt;\epsilon VR$，即$VR$是对称的，则以无序对$(v,w)$代替这两个有序对，表示$v$和$w$之间的一条边Edge，此时的图称为无向图Undigraph。 $$G_2 = (V_2,{E_2})$$ 5.2 图的存储结构 图的结构较为复杂，常用的存储结构有邻接表，十字链表。 5.2.1 邻接表 邻接表Adjacency List是图的一种链式存储结构。 123456789101112131415 #define MAX_VERTEX_NUM 20typedef struct ArcNode &#123; int adjvex; // 该弧所指向的顶点的位置 struct ArcNode *nextarc; // 指向下一条弧的指针 InfoType *info; // 该弧相关信息的指针&#125;ArcNode;typedef struct VNode &#123; VertexType data; // 顶点信息 ArcNode *firstarc; //指向第一条依附该顶点的弧的指针&#125;VNode, AdjList[MAX_VERTEX_NUM];typedef struct &#123; AdjList vertices; int vexnum, arcnum; //图的当前顶点数和弧数 int kind; // 图的种类标志&#125;ALGraph; 5.2.2 十字链表 十字链表Orthogonal List是有向图的另一种链式存储结构。可以看作是将有向图的邻接表和逆邻接表结合起来的一种链表。 1234567891011121314 #define MAX_VERTEX_NUM 20typedef struct ArcBox &#123; int tailvex, headvex; // 该弧的尾和头顶点的位置 struct ArcBox *hlink, *tlink; // 分别为弧头相同和弧尾相同的弧的链域 InfoType *info; // 该弧相关的信息的指针&#125;ArcBox;typedef struct VexNode &#123; VertexType data; ArcBox *firstin, *firstout; // 分别指向该顶点的第一条入弧和出弧&#125;VexNode;typedef struct &#123; VexNode xlist[MAX_VERTEX_NUM]; // 表头向量 int vexnum, arcnum; // 有向图的当前顶点数和弧数&#125;OLGraph; 更多关于图的存储的知识，请戳： 数据结构(16)–图的存储及实现 图的存储结构之邻接表(详解) 图的存储 ( 十字链表 ) -&gt; recommend！ 十字链表的画法 -&gt; recommend！ 5.3 图的遍历 图的遍历Traversing Graph指从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。 5.3.1 深度优先搜索 深度优先搜索Depth_First Search遍历类似于树的先根遍历。 12345678void DFS(Graph G, int v) &#123; //从第v个顶点出发递归地深度优先遍历图G visited[v] = TRUE; visitFunc(v); // 访问第v个顶点 for(w = FirstAdjVex(G,v); w &gt;= 0; w = NextAdjVex(G,v,w)) if(!visited[w]) DFS(G,w); // 对v的尚未访问的邻接顶点w递归调用DFS&#125; 5.3.2 广度优先搜索 广度优先搜索Breadth_First Search遍历类似于树的层次遍历。 123456789101112131415161718192021void BFSTraverse(Graph G, Status(*visit)(int v)) &#123; // 按广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited for(v = 0; v &lt; G.vexnum; ++v) visited[v] = FALSE; InitQuene(Q); // 置空的辅助队列Q for(v = 0; v &lt; G.vexnum; ++v) if(!visited[v]) &#123; // v尚未访问 visited[v] = TRUE; Visit(v); Enquene(Q, v); // v入队列 while(!QueneEmpty(Q)) &#123; DeQuene(Q, u); // 队头元素出列并置为0 for(w = FirstAdjVex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)) if(!Visited[w]) &#123; // w为u的尚未访问的邻接顶点 Visited[w] = TRUE; Visit(w); EnQuene(Q, W); &#125; // if &#125; //while &#125; // if&#125; // BFSTraverse 遍历图的过程实质上是通过边或弧找邻接点的过程，因此广度优先搜索和深度优先搜索地时间复杂度相同。 更多关于图的遍历的知识，请戳： 图的深度优先遍历和广度优先遍历理解 数据结构和算法总结（一）：广度优先搜索BFS和深度优先搜索DFS -&gt; recommend！ 5.4 图的连通性问题 对于连通图来说，从任一顶点出发，便可访问图中所有顶点。而对于非连通地图，则需从多个顶点出发进行搜索。 5.4.1 最小生成树 关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 最小生成树Minimum Cost Spanning Tree指构造连通网的最小代价生成树。 Kruskal算法 此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序； 把图中的n个顶点看成独立的n棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。 Prim算法 此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为V；初始令集合u={s},v=V−u; 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。 由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息： 12345struct&#123; char vertexData //表示u中顶点信息 UINT lowestcost //最小代价&#125;closedge[vexCounts] 更多关于最小生成树的知识，请戳： 算法导论–最小生成树（Kruskal和Prim算法） -&gt; recommend！ 5.5 拓扑排序 拓扑排序Topological Sort指由某个集合上的一个偏序得到该集合上的一个全序。 拓扑排序的实现步骤: 在有向图中选一个没有前驱的顶点并且输出。 从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）。 重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的。 因此，也可以通过拓扑排序来判断一个图是否有环。 更多关于拓扑排序的知识，请戳： 数据结构—拓扑排序详解 5.6 最短路径 最短路径指从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径. 5.6.1 Dijkstra算法 算法特点：迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路 Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点 更多关于最短路径的知识，请戳： 最短路径问题—Dijkstra算法详解 6. 查找 查找Search：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。分类有静态查找和动态查找。 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 6.1 静态查找 6.1.1 顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析： 查找成功的平均查找长度为（假设每个数据元素的概率相等）: $$ASL = 1/n(1+2+3+…+n) = (n+1)/2$$ 当查找不成功时，需要$n+1$次比较，时间复杂度为$O(n)$；所以，顺序查找的时间复杂度为$O(n)$。 C++实现源码： 123456789//顺序查找int SequenceSearch(int a[], int value, int n)&#123; int i; for(i=0; i&lt;n; i++) if(a[i]==value) return i; return -1;&#125; 6.1.2 二分查找（折半查找） 说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 折半查找的平均查找长度：$$ASL_{bs} = \frac{1}{n}\sum_{i=1}^{n}{j\times2^{j-1}} = \frac{n+1}{n}\log_2(n+1) - 1 = \log_2(n+1) - 1 $$ 复杂度分析：最坏情况下，关键词比较次数为$\log_2(n+1)$，且期望时间复杂度为$O(log_2n)$； 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》 C++实现源码： 123456789101112131415161718192021222324252627282930//二分查找（折半查找），非递归版本int BinarySearch1(int a[], int value, int n)&#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; &#125; return -1;&#125;//二分查找，递归版本int BinarySearch2(int a[], int value, int low, int high)&#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high);&#125; 更多查找算法，请戳： 数据结构–七大查找算法总结 【数据结构】静态查找之分块查找 6.2 动态查找 动态查找：当查找表以顺序存储结构存储且需要保持有序时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。 若查找表无序，则插入删除可无需移动大量记录，但于查找不利。 利用树的形式组织查找表，可以对查找表进行动态高效的查找。 6.2.1 二叉排序树 二叉排序树Binary Sort Tree的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。 若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值； 若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值； 左、右子树都分别是二叉排序树。 二叉排序树性能 二叉排序树查找关键字的比较次数，等于该结点所在的层次数（查找成功）； 若查找不成功，其比较次数最多为树的深度。 对于一棵具有n个结点的树来说，其深度介$log_2(n+1)$与$n$之间。 二叉排序树的形态对于查找效率至关重要，或者说，一棵二叉排序树不一定就能提高查找的速度，而是要看这棵树的形态。 注：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。 更多动态查找的知识，请戳： 数据结构-动态查找 查找算法总结之二（动态查找表） 6.3 哈希表 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。 哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。 键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。 槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。 哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。 哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。 更多哈希表的知识，请戳： 浅谈哈希表(HashTable) -&gt; recommend！ 程序员常说的「哈希表」是个什么鬼? 7. 内部排序 内部排序指待排序记录存放在计算机随机存储器（如内存）中进行的排序过程。外部排序指待排序记录的数量很大，以致于内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。 注：我们常常用到的是内部排序。 7.1 插入排序 7.1.1 直接插入排序 介绍 直接插入排序Straight Insertion Sort是基于比较的排序。所谓的基于比较，就是通过比较数组中的元素，看谁大谁小，根据结果来调整元素的位置。 因此，对于这类排序，就有两种基本的操作：①比较操作； ②交换操作 其中，对于交换操作，可以优化成移动操作，即不直接进行两个元素的交换，还是用一个枢轴元素(tmp)将当前元素先保存起来，然后执行移动操作，待确定了最终位置后，再将当前元素放入合适的位置。（下面的插入排序就用到了这个技巧）–因为，交换操作需要三次赋值，而移动操作只需要一次赋值！ 有些排序算法，比较次数比较多，而移动次数比较少，而有些则相反。比如，归并排序和快速排序，前者移动次数比较多，而后者比较次数比较多。 复杂度分析 插入排序在实现上，通常采用in-place排序（即只需用到$O(1)$的空间复杂度和$O(N^2)$的时间复杂度）），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 12345678910111213141516171819202122void Insertsort1(int a[], int n) &#123; int i, j, k; for (i = 1; i &lt; n; i++) &#123; //为a[i]在前面的a[0...i-1]有序区间中找一个合适的位置 for (j = i - 1; j &gt;= 0; j--) if (a[j] &lt; a[i]) break; //如找到了一个合适的位置 if (j != i - 1) &#123; //将比a[i]大的数据向后移 int temp = a[i]; for (k = i - 1; k &gt; j; k--) a[k + 1] = a[k]; //将a[i]放到正确位置上 a[k + 1] = temp; &#125; &#125; &#125; 更多直接插入排序的知识，请戳： 插入排序算法详解及实现 白话经典算法系列之二 直接插入排序的三种实现 7.1.2 折半插入排序 插入排序的基本操作是在一个有序表中进行查找和插入。利用“折半查找”的查找操作实现的插入排序，称为折半插入排序Binary Insertion Sort。 12345678910111213141516void InsertSort(Elemtype A[],int n)&#123; int i,j,low,high,mid; for(i=2;i&lt;=n;i++)&#123; A[0]=A[i]; low=1; high=i-1;//设置折半查找的范围，从1到i-1,A[0]用来暂存元素 while(low&lt;=high)&#123; mid=(low+high)/2; if(A[mid].key&gt;A[0].key) high=mid-1;//查找左半子表 else low=mid+1;//查找右半子表 &#125; for(j=i-1;j&gt;=high+1;--j) A[j+1]=A[j];//统一向后移动元素，空出插入位置 A[high+1]=A[0];//插入操作 &#125;&#125; 更多折半插入排序的知识，请戳： 数据结构折半插入排序 -&gt;recommend！ 7.1.3 希尔排序 希尔排序Shell&#39;s Sort又称最小增量排序，它的基本思想是将整个待排序记录序列分割成若干个子序列分别进行插入排序，待整个序列的记录“基本有序”时，再对全体记录进行一次直接插入排序。 1234567891011121314151617181920void ShellSort(int array[], int len) // O(n*n)&#123; int i = 0; int j = 0; int k = -1; int temp = -1; int gap = len; do &#123; gap = gap / 3 + 1; for (i=gap; i&lt;len; i+=gap) &#123; k = i; temp = array[k]; for (j=i-gap; (j&gt;=0) &amp;&amp; (array[j]&gt;temp); j-=gap) &#123; array[j+gap] = array[j]; k = j; &#125; array[k] = temp; &#125; &#125; while (gap &gt; 1);&#125; 更多希尔排序的知识，请戳： 图解排序算法(二)之希尔排序 希尔排序详解 -&gt;recommend！ 排序五：希尔排序 -&gt;recommend！ 7.2 交换排序 7.2.1 冒泡排序 冒泡排序算法的运作如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度 冒泡排序最好的时间复杂度为 $O(n)$。冒泡排序的最坏时间复杂度为 $O(n^2)$。综上，因此冒泡排序总的平均时间复杂度为 $O(n^2)$。 算法稳定性 冒泡排序Bubble Sort就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 123456789101112void bubble_sort(T arr[], int len)&#123; int i, j; T temp; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125;&#125; 更多冒泡排序的知识，请戳： 白话经典算法系列之一 冒泡排序的三种实现 经典排序算法学习笔记一——冒泡排序 7.2.2 快速排序 快速排序Quick Sort是对冒泡排序的一种改进。它的基本思想是，通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，继续进行排序以达到整个序列有序。 123456789101112131415161718192021222324252627282930int PartSort1(int* a,int left,int right)//左右指针法 &#123; int mid = GetMidIndex(a,left,right); //此处是对快排的优化，再后面会提到 swap(a[mid],a[right]); int key = right;//利用key作为基准值的下标 while (left &lt; right) &#123; //左指针向右找第一个比key大的数 while (left &lt; right &amp;&amp; a[left] &lt;= a[key]) &#123; ++left; &#125; //右指针向左扎找第一个比key的数 while (left &lt; right &amp;&amp; a[right] &gt;= a[key]) &#123; --right; &#125; //交换左右指针所指的值 if (a[left] != a[right]) &#123; std::swap(a[left],a[right]); &#125; &#125; //将key值放到正确位置上 swap(a[left],a[key]); return left; &#125; 快速排序的时间复杂度为：$O(nlogn)$ 更多快速排序的知识，请戳： 快速排序基本思路（通俗易懂+例子） 快速排序 快速排序基本思路（通俗易懂+例子） -&gt;recommend！ 图解快速排序 -&gt;recommend！ 7.3 选择排序 选择排序Selection Sort：每一趟在$n-i+1(i=1,2,3,…,n-1)$个记录中选取关键字最小的记录作为有序序列的第$i$个记录。 7.3.1 简单选择排序 一趟简单选择排序的操作是：通过$n-i$次关键字间的比较，从$n-i+1(i=1,2,3,…,n-1)$个记录中选取关键字最小的记录，并和第$i$个记录交换之。 简单选择排序的时间复杂度为$O(n^2)$ 1234567891011121314151617181920void select_sort(int A[],int n)&#123; register int i,j,min,m; for(i=0;i&lt;n-1;i++) &#123; min=i;//查找最小值 for(j=i+1;j&lt;n;j++) &#123; if(A[min]&gt;A[j]) &#123; min=j; &#125; &#125; if(min!=i) &#123; swap(&amp;A[min],&amp;A[i]); &#125; &#125;&#125; 稳定性 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。 更多关于选择排序的知识，请戳： 经典排序算法之选择排序 7.3.2 堆排序 堆排序Heap Sort是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为$O(nlogn)$，它也是不稳定排序。首先简单了解下堆结构。 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void swap(int *a, int *b);void adjustHeap(int param1,int j, int inNums[]);void HeapSort(int nums, int inNums[]);//大根堆进行调整void adjustHeap(int param1, int j, int inNums[])&#123; int temp=inNums[param1]; for (int k=param1*2+1;k&lt;j;k=k*2+1) &#123; //如果右边值大于左边值，指向右边 if (k+1&lt;j &amp;&amp; inNums[k]&lt; inNums[k+1]) &#123; k++; &#125; //如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换） if (inNums[k]&gt;temp) &#123; inNums[param1]=inNums[k]; param1=k; &#125; else break; &#125; //put the value in the final position inNums[param1]=temp;&#125;//堆排序主要算法void HeapSort(int nums,int inNums[])&#123; //1.构建大顶堆 for (int i=nums/2-1;i&gt;=0;i--) &#123; //put the value in the final position adjustHeap(i,nums,inNums); &#125; //2.调整堆结构+交换堆顶元素与末尾元素 for (int j=nums-1;j&gt;0;j--) &#123; //堆顶元素和末尾元素进行交换 int temp=inNums[0]; inNums[0]=inNums[j]; inNums[j]=temp; adjustHeap(0,j,inNums);//重新对堆进行调整 &#125;&#125; 更多堆排序的知识，请戳： 浅谈堆排序 堆排序详解 -&gt;recommend！ 图解排序算法(三)之堆排序 7.4 归并排序 归并排序Merging Sort是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//将有二个有序数列a[first...mid]和a[mid...last]合并。 void mergearray(int a[], int first, int mid, int last, int temp[]) &#123; int i = first, j = mid + 1; int m = mid, n = last; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= n) &#123; if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; while (i &lt;= m) temp[k++] = a[i++]; while (j &lt;= n) temp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[first + i] = temp[i]; &#125; void mergesort(int a[], int first, int last, int temp[]) &#123; if (first &lt; last) &#123; int mid = (first + last) / 2; mergesort(a, first, mid, temp); //左边有序 mergesort(a, mid + 1, last, temp); //右边有序 mergearray(a, first, mid, last, temp); //再将二个有序数列合并 &#125; &#125; bool MergeSort(int a[], int n) &#123; int *p = new int[n]; if (p == NULL) return false; mergesort(a, 0, n - 1, p); delete[] p; return true; &#125; 白话经典算法系列之五 归并排序的实现 总结在数据结构和算法的路上，越走越远！~]]></content>
  </entry>
  <entry>
    <title><![CDATA[初识wsl（Windows Subsystem for Linux），微软这次真的给了我惊喜！]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%88%9D%E8%AF%86wsl%EF%BC%88Windows-Subsystem-for-Linux%EF%BC%89%E7%9A%84Surprise%EF%BC%8C%E5%BE%AE%E8%BD%AF%E8%BF%99%E6%AC%A1%E7%9C%9F%E7%9A%84%E7%BB%99%E4%BA%86%E6%88%91%E6%83%8A%E5%96%9C%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Surprise！这次，微软给了我们一个surprise！当然，我得到的消息是不是太晚！！因为，我看知乎他们似乎在两年前就开始尝鲜WSL了，但那时的wsl似乎还是不太稳定的，而到了2018年，在体验了WSL后，我对她非常满意！嗯，就像微软所说，Windows love Linux，而wsl的的确确地让我体验到了Linux的feel！不得不感慨，巨硬大法好👌！]]></content>
  </entry>
  <entry>
    <title><![CDATA[全站https化&全方位SEO优化！焕然一新喔～]]></title>
    <url>%2F2018%2F04%2F13%2F%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BC%98%E5%8C%96%EF%BC%81%E7%84%95%E7%84%B6%E4%B8%80%E6%96%B0%E5%96%94%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[前言最近学习一些信息安全和计算机网络方面的知识，知道了http和https的差距，现在全网各大网站和平台都在进行全站https化，所以我准备把我的fuujiro’s land也实现一波全站https化。除了这个之外，我也打算对我的blog进行SEO优化。SEO优化这是门大学问，不论是我这样的小小blog，还是大厂的页面，都会试图让自家的产品和网站出现在搜索引擎最靠前的位置，SEO优化大概就是在干这样一件事～ 1. 实现全站https化1.1 为什么要进行https化先说说http和https的区别： HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 其中HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 所以～尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 So，大家赶紧一起撸起袖子把自己的网站 or 博客实现全站https化吧！！ 1.2 所需要的工具和基础： 仓库：Github Hexo 博客主题：Apollo 评论插件：Disqus SSL证书 &amp; 服务器：CloudFlare 个人域名(腾讯云)一个 注意：如果你的hexo blog并没有自己额外购买的独立域名如fuujiro.com，在使用GitHub Pages自带的yourname.github.io，那么其实你是不需要进行手动https，因为*GitHub Pages自带https优化了。买独立域名的优势是可以让搜索引擎检索到，比如百度这种公司是不检索github.io的… 1.3 步骤现在默认已经将博客搭好了，也链接上了自己的独立域名，如果没有，请参考我的另一篇博客：使用Hexo框架+Apollo主题搭建博客 1.3.1 注册一个CloudFlare账户 首先进入cloudflare，注册好你的账户，然后绑好你的个人域名。教程：如何注册使用cloudfare？ 进行完第一步的基本操作后，你会得到cloudfare赏给你的两个服务器DNS地址： 把这两个地址copy好，打开你购买你的域名的服务商，比如我用的是腾讯云。按下面步骤操作，其他网站也大同小异，就是修改一下域名的DNS服务器。 最后，使用whois工具查看是否已经更改服务器成功。 更改之前(我的域名是腾讯云购买的，所以云解析的服务器也是腾讯云)。 更改以后，服务器DNS解析转移到cloudfare服务器。 这意味着你去成功了，这时候进入cloudfare主页，你的域名的状态就是Active了(可能cloudfare因为服务器缓存的原因，会晚几小时，不过如果whois查看已修改了，基本没有问题)，就像下面这样。 注意：以下所有操作的前提建立在，域名的状态是Active： 如果域名状态还未变绿，说明你还不够成熟，请您继续上面两步的操作。因为你继续下去也不会有结果，就像你死缠难打也不会有女朋友一样。 接下来，就是cloudfare的优化操作了。 实现全站https化 实现网站加速（关于Page Rules可以搜索引擎了解） 至此，你重新刷新的网站or博客页面，域名地址左侧出现绿色小锁标识，恭喜你，你已经实现https化。至于全站https化，请保持你网站上所有引用的图片链接，也必须是https网站的，否则无法实现全站https化，实现https后的fuujiro’s island： 2. 全方位SEO优化 未完待续…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vim-蓝色星球迄今为止最强大的编辑器（持续更新]]></title>
    <url>%2F2018%2F03%2F10%2Fvim-%E8%93%9D%E8%89%B2%E6%98%9F%E7%90%83%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1. 故事 - “编辑器之神”为什么Vim被称为编辑器之神？话说啊，远古时候，有两大神仙，地上很多猿类大多分成两派，一部分仰慕Vim大神，另一部分崇拜Emacs大仙，这两派互相挖苦比较，只相信自己的信仰之神是最强大的！我呢，暂时站Vim神的，不排除以后叛变啦！ 好了，正经说话吧！高校里教学c语言时，应该是用的VC++6.0 or VS2010，这两个是编辑器嘛？当然，不是的！他们都是集成开发环境（IDE，Integrated Development Environment）,而Vim才是编辑器，与vim一起称作编辑器还有啥子呢？比如，Emacs（Vim在这个世界上的最强大对手）,VS code（Microsoft推出的开源编辑器，是我最近使用的最频繁的编辑器，可以说面对学习曲线陡峭的Vim来说，VS code是最容易上手的编辑器，我现在在写的这篇blog就是用VS code写的，插件十分丰富，除了由于GUI界面的存在，可能在内存上稍高于Vim，但比起鬼畜的Atom来说，那是好到不知道哪里去了的存在）,Atom（Google推出的开源编辑器，同样因为开源的原因，插件十分丰富）,Sublime Text（前端engineer一定经历过的编辑器，插件丰富，性能极优）等等…… 好了，你现在肯定会问我，为啥我这次blog只介绍Vim呢？因为，Vim难学啊！这里有一张网上嘲讽几大编辑器的学习曲线～ 2. 学习Vim能给你带来什么？从图上我们能看出，vim（vi）的学习曲线入门是十分陡峭的，Emacs的略显鬼畜2333～！那，学习Vim对于我来说，到底有什么什么好处呢？我在刚刚学习Vim时，也是有抱着这个疑惑的，后来总是强迫自己去学+在网上了解Vim，我觉得学习对你可能会有这些好处： 熟悉命令行工具：Vim是在终端（Terminal）上运行的编辑器，学习Vim无疑你会在命令行下进行频繁操作，而命令行工具对于程序员来说，是十分重要的！也许大部分同学的开发环境大部分还是Windows，使用命令行工具的机会很少！但是以后科研or工作，开发平台就不一定是Windows了，也不一定会有带图形界面的开发工具给你使用。比如： 你科研跑TensorFlow，进行深度学习方面的科研，大概率会需要在linux上跑；做机器学习离不开Linux～我最近在做计算机视觉（Computer Vision）的研究，小方向现在做的是对机械臂进行视觉定位，然而这个机械臂的ROS操作工具，就必须在Linux下进行~～macOS&amp;Windows都没提供~~ 你是EE爱好者（robot开发方向的爱好者），而ROS (Robot Operating System, 机器人操作系统) 恰恰只提供给你Linux的开发工具（且只保证Ubuntu（Linux的一个发行版）能够完美兼容），你作为机器人方向开发者，无法避免命令行工具的使用 除了科研界，工程界对于命令行工具的使用不要太多！各大互联网的大厂的每一个开发岗offer，无论你是c/c++/java/python/c#/前端/运维等，哪个岗位要求都会有这么一句“熟悉使用命令行操作工具”or“熟悉shell脚本语言编程”，可以说，使用命令行工具是一位合格的计算机专业大学生应该具有的。 Vim具有其他编辑器不具有的与生俱来的特殊功能，比如轻松运用SSH（SSH指：. Secure Shell（缩写：SSH），即“安全壳协议”，一项计算机上的安全协议）；Vim内存占用很低，对于开发配置要求极低，比起具有图形界面的VS code，Atom，Sublime来说，可以说能开机的电脑都能顺溜地跑Vim～！ 最后一个：Vim能帮助乌干达的贫苦儿童，这是个梗2333～！不过，认真讲哦～你用Vim写代码，是在帮助世界上的其他小孩子呢！还有什么理由，不好好写代码233～！ 相信前面的大串理由，你一定拒绝不了Vim的诱惑，不如和我一起来学习Vim工具吧～啦啦啦～！ 3. Vim介绍以及如何入门3.1 Vim和Vi的关系通过搜索引擎了解一下，就简单黏上来了！自己写的没有这么全面～123456789101112Vim和Vi都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。vim的这些优势主要体现在以下几个方面：1、多级撤消我们知道在vi里，按`u`只能撤消上次命令，而在vim里可以无限制的撤消。2、易用性vi只能运行于unix中，而vim不仅可以运行于unix,windows ,mac等多操作平台。3、语法加亮vim可以用不同的颜色来加亮你的代码。4、可视化操作就是说vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows。5、对vi的完全兼容某些情况下，你可以把vim当成vi来使用。 所以，我们通常就把Vim包括了Vi啦～！ 3.2 Vim安装按道理来说，现如今的操作系统（除Windows）都已经自带好了Vim。为了避免古老版本只安装Vi的gg情况，我们可以先敲1$ vim -version 来确定计算机是否已经安装好了Vim，一般出现的结果就是：12fuujiro-Mac:~ fuujiro$ vim -versionVIM - Vi IMproved 8.0 (2016 Sep 12, compiled Jul 26 2017 19:10:24) 如上结果的话，你的计算机就已经安装好了Vim，版本是8.0。当然如果提示command not found，那也不慌，我们装上就好： Linux用户： 因为Linux存在两大派系，Debian和Redhat，对于不同派系，安装命令也不相同。 1234ubuntu系统（基于Debian）：普通用户下输入命令：sudo apt-get install vim-gtkcentos系统（基于Redhat）：普通用户下输入命令：yum -y install vim* macOS用户： macOS是自带Vim的，但由于随系统版本的原因，可能版本落后，那就讲一下Vim的升级吧～！ 我是推荐用Homebrew（Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程）来升级的。 安装Homebrew 1$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装or升级Vim 1234安装Vim$ brew install vim升级Vim$ brew update vim Windows用户 Windows因为不是*nix类系统，所以不会自带Vim，不过已经有大牛开发出了vim在Windows上的编辑器-gvim gvim+w7+vundle安装教程上面这个文章清晰的解释了每一步，跟着做就好。 3.3 Vim入门3.3.1 vim的基础模式在使用vim时，主要你会在两个模式下操作： 正常（normal）模式：任何其它模式中都可以通过键盘上的 Esc 键回到正常模式。在这个模式下可以进行命令（commmand）模式操作（按:进入）。例如，wq是保存并退出，q!是强制退出不保存。 输入（insert）模式，输入文本时使用；在正常模式下键入“i”（insert）或“a”（append）即可进入插入模式。这时候一般进行文本编辑工作，例如写代码。 当然除了这两种模式，还有可视（visual）模式：用于选定文本块；可以在正常模式下输入“v”（小写）来按字符选定，输入“V”（大写）来按行选定，或输入“Ctrl-V”来按方块选定。主要的话，还是上面那2种模式用的比较多。 3.3.2 vim的基本操作你如果是第一次接触命令行，可以在打开终端（open terminal），敲下vimtutor然后按下回车，就可以看到（如下图） 这是vim的学习文档，文档语言取决于你的系统语言，所以不会英语的小伙伴也不必害怕学习vim，毕竟中文文档也是挺丰富的，不过我还是推荐学习好英语的。 好，现在默认大家都已经跟着vimtutor过了一遍了，那再复现一下文档里的一些主要的操作。 注意： 首先是控制光标移动的方向键，依然还是可以用上下左右键的，不过vim发明者的本意是提高使用者的打字效率，所以推荐h,j,k,l这4个键分别，这样你的双手就不用离开主键盘区了，完完全全的效率工具。当然，刚刚开始使用时，你会觉得有点变扭，不过熟悉后你肯定会赞成我这句话的。 在插入模式下按:键就可以进入命令模式；在命令模式下按i就可以进入插入模式。在插入模式下，输入wq可以保存并退出文件，按q!是强制退出不保存。如果有需要保存的路径，那么就w+空格+保存文件的路径。 总结的详细操作： 命令历史以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。 启动vim在命令行窗口中输入以下命令即可 vim 直接启动vim vim filename 打开vim并创建名为filename的文件 文件命令打开单个文件 vim file 同时打开多个文件 vim file1 file2 file3 … 在vim窗口中打开一个新文件 :open file 在新窗口中打开文件 :split file 切换到下一个文件 :bn 切换到上一个文件 :bp 查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。 :args 打开远程文件，比如ftp或者share folder :e ftp://192.168.10.76/abc.txt :e \qadrive\test\1.txt vim的模式正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i键进入） 左下角显示–INSERT–可视模式（不知道如何进入） 左下角显示–VISUAL– 导航命令% 括号匹配 插入命令i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 查找命令/text 查找text，按n健查找下一个，按N健查找前一个。 ?text 查找text，反向查找，按n健查找下一个，按N健查找前一个。 vim中有一些特殊字符在查找时需要转义 .*[]^%/?~$ :set ignorecase 忽略大小写的查找 :set noignorecase 不忽略大小写的查找 查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。 :set hlsearch 高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。 :set nohlsearch 关闭高亮搜索显示 :nohlsearch 关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。 :set incsearch 逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。 :set wrapscan 重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。 替换命令ra 将当前字符替换为a，当期字符即光标所在字符。 s/old/new/ 用old替换new，替换当前行的第一个匹配 s/old/new/g 用old替换new，替换当前行的所有匹配 %s/old/new/ 用old替换new，替换所有行的第一个匹配 %s/old/new/g 用old替换new，替换整个文件的所有匹配 :10,20 s/^/ /g 在第10行知第20行每行前面加四个空格，用于缩进。 ddp 交换光标所在行和其下紧邻的一行。 移动命令h 左移一个字符l 右移一个字符，这个命令很少用，一般用w代替。k 上移一个字符j 下移一个字符以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！，这里的Esc是必须的，否则命令不生效。 w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。 b 向后移动一个单词 2b 向后移动2个单词 e，同w，只不过是光标停在单词尾部 ge，同b，光标停在单词尾部。 ^ 移动到本行第一个非空白字符上。 0（数字0）移动到本行第一个字符上， 移动到本行第一个字符。同0健。 $ 移动到行尾 3$ 移动到下面3行的行尾 gg 移动到文件头。 = [[ G（shift + g） 移动到文件尾。 = ]] f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。 F 同f，反向查找。 跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。 Ctrl + e 向下滚动一行 Ctrl + y 向上滚动一行 Ctrl + d 向下滚动半屏 Ctrl + u 向上滚动半屏 Ctrl + f 向下滚动一屏 Ctrl + b 向上滚动一屏 撤销和重做u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做（Redo），即撤销的撤销。 删除命令x 删除当前字符 3x 删除当前光标开始向后三个字符 X 删除当前字符的前一个字符。X=dh dl 删除当前字符， dl=x dh 删除前一个字符 dd 删除当前行 dj 删除上一行 dk 删除下一行 10d 删除当前行开始的10行。 D 删除当前字符至行尾。D=d$ d$ 删除当前字符之后的所有字符（本行） kdgg 删除当前行之前所有行（不包括当前行） jdG（jd shift + g） 删除当前行之后所有行（不包括当前行） :1,10d 删除1-10行 :11,$d 删除11行及以后所有的行 :1,$d 删除所有行 J(shift + j) 删除两行之间的空行，实际上是合并两行。 拷贝和粘贴yy 拷贝当前行 nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。 p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。 shift+p 在当前行前粘贴 :1,10 co 20 将1-10行插入到第20行之后。 :1,$ co $ 将整个文件复制一份并添加到文件尾部。 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制 ddp交换当前行和其下一行 xp交换当前字符和其后一个字符 剪切命令正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切 ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴 :1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。 :1, 10 m 20 将第1-10行移动到第20行之后。 退出命令:wq 保存并退出 ZZ 保存并退出 :q! 强制退出并忽略所有更改 :e! 放弃所有修改，并打开原来文件。 窗口命令:split或new 打开一个新窗口，光标停在顶层的窗口上 :split file或:new file 用新窗口打开文件 split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。 Ctrl+ww 移动到下一个窗口 Ctrl+wj 移动到下方的窗口 Ctrl+wk 移动到上方的窗口 关闭窗口 :close 最后一个窗口不能使用此命令，可以防止意外退出vim。 :q 如果是最后一个被关闭的窗口，那么将退出vim。 ZZ 保存并退出。 关闭所有窗口，只保留当前窗口 :only 录制宏 按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。 执行shell命令:!command :!ls 列出当前目录下文件 :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。 :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。 :suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。 注释命令perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入# 3,5 s/^/#/g 注释第3-5行 3,5 s/^#//g 解除3-5行的注释 1,$ s/^/#/g 注释整个文档。 :%s/^/#/g 注释整个文档，此法更快。 帮助命令:help or F1 显示整个帮助:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help ‘number’ Vim选项的帮助用单引号括起:help 特殊键的帮助用&lt;&gt;扩起:help -t Vim启动参数的帮助用-：help i_ 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回 其他非编辑命令. 重复前一次命令 :set ruler? 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看 :scriptnames 查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。 :set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。 Vim教程 在Unix系统上 $ vimtutor 在Windows系统上 :help tutor :syntax 列出已经定义的语法项:syntax clear 清除已定义的语法规则:syntax case match 大小写敏感，int和Int将视为不同的语法元素:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案 最后贴2张Vim的命令大全图，可以留着当壁纸，时不时看几眼，没准就都记住了呢～ 4. Vim的终极配置vim是一个开放性很强的编辑器，个性化定制很丰富，你可以创建一个完全自我定制的vimrc，然后自己选择一些插件安装。不过，我推荐一个高度定制好的vim配置，正在使用的，它不一定是完美的，但的确是一款好用的。那就是spf13-vim，它的官方地址是： spf13-vim官网 spf13-vim的GitHUb仓库地址 这两个地址，都有详细的安装介绍，我就不多说了，打字受累，大家可以参考介绍，搭建你自己的vim终极配置！ 5. Vim使用时遇到过的问题及处理方法（持续更新祝大家使用Vim更加爽快～！在编程的道路上越走越远～！ 致谢： 令狐葱@前端笔记 吴润的知乎专栏：cs专业那些事 vim常用命令总结 （转)]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo框架+Apollo主题搭建博客]]></title>
    <url>%2F2018%2F02%2F14%2F%E4%BD%BF%E7%94%A8Hexo%E6%A1%86%E6%9E%B6-Apollo%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言时间过得贼快啊！我一下子就要大二下学期了！想着自己以后大概率就是一名老实的程序员。按着这个程序猿们的习惯啊，一般都会有个自己的博客，也不论是追求技术还是跟风吧，我脑子一热呢，就准备搭一个自己的Blog。 脑子热的时候是2月11号晚上，然后既然热了，那就行动呗。先google了一下个人博客的主流框架和搭建入门咯。最后还是放弃了Wordpress，选择了Hexo来搭建，原因是Hexo开源，主题选择丰富，emmmm就酱。关于为啥选择apollo主题呢，主要是有天瞎逛时，误入了phoenixlzx巨巨的blog，他用的就是Apollo主题。我定睛一看，这就是我想要的滑板鞋主题！ Apollo主题的开发者据说是一位92年的小哥哥，开发Apollo的时候在美团前端任职，现在根据他的GitHub主页应该是在Alipay工作了。我选择Apollo主题的原因是因为它风格简约，我觉得浏览时加载体验比博客华丽的外观会重要很多，你想想等加载是很烦躁的一件事（嗯，至少来说我是这样…），何况Apollo还简约得好看一匹，果断Mark。如下图。 嗯！真的很耐看！清新，简约，Nice！ 既然选择好了框架+主题，就进入正式阶段（以下一切安装代码，在OS X无问题，Windows可能会要稍作修改）。 1. 安装Hexo因为Hexo是一款基于Node.js的静态博客框架，生成静态网页托管在GitHub。所以我们在安装Hexo前得先装上Node.js和git。 1.1 安装Node.js 下载Node.js 安装Node.js 1.2 安装git 下载git（可能会有墙的限制，请翻墙|在网盘or网站CSDN上都可以找到离线包） 安装git 配置自己的git（重要：别忘了这步） 1.3 安装Hexo因为已经装好了Node.js环境了，所以可以使用npm命令。 使用npm命令安装Hexo，输入：12345$ npm install -g hexo-cli or$ npm install -g hexo 如果收到error，在命令行首加上sudo。 初始化博客找到你要放置博客的根目录（推荐建立一个文件夹用来放置，强迫症必须不得不这么干），建好了我们就开始初始化，比如我们已经了创建了一个名为blog的文件夹程序员最好不要创造出有中文的路径吧。 1$ hexo init blog 常规操作接下来搭个静态界面，看看预期，满足下心脏。 1234$ cd blog #切到blog文件夹下$ npm install $ hexo g$ hexo s 按照正常操作，这时候命令行会抛出一个链接http://localhost:4000/，你复制这串网址粘贴到浏览器打开，不出错误的话，会看到第一个由Hexo框架搭建的网页。如果这时候，你没看到or失败了，可能需要google一下。 接着，普及一下Hexo框架的基本操作和作用 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署博客到远端（比如github平台） hexo clean 清除缓存 你还会用到1234$ hexo new &quot;postName&quot; #新建博客的文章$ hexo new page &quot;pageName&quot; #新建博客的页面$ hexo g &amp;&amp; hexo d #生成部署$ hexo s #生成本地预览 我写这篇文章时的本地环境，你可以参考一下（使用hexo -v查看，我使用的是OS X系统搭建）12345678910111213141516hexo: 3.5.0hexo-cli: 1.0.4os: Darwin 17.2.0 darwin x64http_parser: 2.7.0node: 8.9.4v8: 6.1.534.50uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 2. apollo主题配置2.1 安装1234$ cd Blog $ npm install$ npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive$ git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo 2.2 启用修改_config.yml的theme配置项为apollo1234567theme: apolloarchive_generator: per_page: 0 yearly: false monthly: false daily: false 2.3 测试1$ hexo s 浏览器打开http://localhost:4000/，看有没有出现apollo标准样式博客，如果没有成功，请自行Google查错。 2.4 更新12$ cd themes/apollo $ git pull 3. 托管到GitHub + 链接个人域名3.1 基本准备 GitHub账户一个 一个自定义域名（从阿里云，腾讯云等都可以购买，自带解析服务，推荐；当然也可以选择国外网站，不过国内访问速度可能会稍差一点） 我默认你会基本git和GitHub操作，嗯！如果不会，请移步廖雪峰老师的git教程。 3.2 托管步骤我们利用GitHub Pages来介绍托管在GitHub的项目。由于GitHub Pages的空间免费稳定，用来做搭建一个博客再好不过了。 如何搭建一个独立博客——简明Github Pages与Hexo教程 上面这篇博文详细的介绍了ssh key的获取和链接，介绍了GitHub Pages上面搭建Hexo博客的步骤. 关键点： 3.2.1 设置ssh-key 配置 SSH keys 我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。 检查 SSH keys的设置 首先我们需要检查电脑上是否已有ssh key： 1$ cd ~/.ssh 检查本机的ssh密钥 如果提示的是No such file or directory，说明你是第一次在本机上使用，需要创建一个。 生成新的 SSH Key 123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就OK&gt; 此处的邮箱地址，推荐使用你的GitHub账户邮箱 此处的「-C」的是大写的「C」 然后系统会要你输入密码： 12$ Enter passphrase (empty for no passphrase):&lt;输入密码&gt;$ Enter same passphrase again:&lt;再次输入密码&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 其实没必要设置，完全可以敲两下回车；当然设置也没有关系 注意：输入密码的时候没有 * 字样的，你直接输入就可以了。（我个人觉得git还可以完善的一个细节） 最后看到这样的界面，就成功设置ssh key了： 3.2.2 添加ssh key到GitHub在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。 1、打开本地 id_rsa.pub 文件（如：/Users/fuujiro/.ssh/id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 2、登陆 GitHub 系统。点击右上角的Account Settings—&gt;SSH Public keys—&gt;add another public keys 把你本地生成的密钥复制到里面（key文本框中）， 点击add key就ok了 3.2.3 测试可以输入下面的命令，看看设置是否成功，git@GitHub.com 的部分不要修改：1$ ssh -T git@GitHub.com 按道理会显示下面的反馈：123The authenticity of host &apos;GitHub.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes就ok，按道理会显示：1Hi （你的GitHub名字）! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 恭喜你！SSH Key 配置成功！本机已成功连接到 GitHub。 当然，比较倒霉。如果没按道理，大部分可能是墙的原因，你可能需要ping git@GitHub.com拿d到IP地址，然后在/hosts里添加上这个解析。请自行Google解决这个little issue 一个常见错误：GitHub Help - Error Permission denied (publickey) 3.3 将独立域名与 GitHub Pages 的空间绑定 DNS设置 or 域名解析我用的腾讯云的控制台，找到域名，点一下右侧的解析按钮即可解决。阿里云买的域名也可以由阿里云解析。这里也可以使用DNSpod，注册一个账户，即可解析域名了，但应该仅限于解析国内域名。国外的域名，如GoDaddy，请上GoDaddy自行修改DNS。 如何设置DNS 主要有以下几项设置需要填写（以域名fuujiro.com为例）： 主机记录 www：解析后的域名为 www.fuujiro.com @：直接解析主域名 fuujiro.com ：泛解析，匹配其他所有域名 `.fuujiro.com` mail：将域名解析为 mail.fuujiro.com，通常用于解析邮箱服务器 二级域名：如blog.fuujiro.com，填写blog 手机网站：m.fuujiro.com，填写m 记录类型 A：将域名指向云服务器，请选择「A」； CNAME：将域名指向另一个域名，请选择「CNAME」； MX：建立邮箱请选择「MX」，根据邮箱服务商提供的MX记录填写。 记录值：填写需要链接的那个域名，如：fuujiro.github.io 例：如果我们需要把fuujiro.github.io和blog.fuujiro.com链接，主机记录：blog，记录类型：CNAME，记录值：fuujiro.github.io。 然后在你的博客根目录下，找到/source文件夹，进入文件夹，创建一个无格式的名为CNAME的文本文件，文件里填好blog.fuujiro.com（你的个人域名） 测试浏览器打开你的个人域名如blog.fuujiro.com，查看是否加载出页面，如果成功！恭喜你啊，你所有步骤基本完成，尽情地享受你的个人blog，开始码代码吧！頑張って！ 4.后记本来情人节当晚，我就完成了blog的全部搭建我就准备开始写这篇文章了，emmmm也就是昨晚了，结果写着写着就困了，就睡觉去了知道我为什么这么菜了吧我真的很懒。然后今天白天，按着假期规律呗，中午11点多起床，码了几行字，然后吃饭陪我爸聊天，买衣服，陪弟弟放鞭炮在大年三十完成这篇文章的flag就倒了，无情地倒下了！ 不过我没有放弃，继续加油，还是在大年初一，emmmm完结了这篇blog！也谢谢你看到这里，祝你在狗年新年快乐～万事如意！狗年不再出bug！！hahah~ 致谢： 令狐葱@前端笔记 吴润的知乎专栏：cs专业那些事]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown简单语法入门]]></title>
    <url>%2F2018%2F02%2F14%2FMarkdown%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 这是Cmd Markdown 的广告，我觉得写的不错，作为学习markdown语法的入门文档最好不过啦~！ 原文档我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 更多Markdown用法，请戳： Markdown中数学公式整理]]></content>
  </entry>
</search>
