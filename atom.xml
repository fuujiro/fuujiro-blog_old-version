<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fuujiro&#39;s island</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.fuujiro.com/"/>
  <updated>2018-06-12T11:00:36.498Z</updated>
  <id>https://blog.fuujiro.com/</id>
  
  <author>
    <name>fuujiro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NJU-计算机系统基础笔记</title>
    <link href="https://blog.fuujiro.com/2018/05/22/NJU-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.fuujiro.com/2018/05/22/NJU-计算机系统基础笔记/</id>
    <published>2018-05-22T10:42:43.000Z</published>
    <updated>2018-06-12T11:00:36.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>准备自学csapp了，怕听不懂课。知乎说NJU的袁春华老师讲的<strong>计算机系统基础</strong>特别好，所以准备先学这个好了。</p><h3 id="1-第一章"><a href="#1-第一章" class="headerlink" title="1. 第一章"></a>1. 第一章</h3><h4 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h4><blockquote><p>计算机系统抽象层，从上至下依次是：应用（问题），算法，编程（语言），操作系统/虚拟机，指令集体系结构（ISA），微体系结构，功能部件，电路，器件。<strong>指令集体系结构</strong>是软件和硬件的交界层。</p></blockquote><h4 id="1-2-程序开发和执行过程简介"><a href="#1-2-程序开发和执行过程简介" class="headerlink" title="1.2 程序开发和执行过程简介"></a>1.2 程序开发和执行过程简介</h4><ol><li>指令包含操作码和操作数或其他地址码</li><li>机器语言和汇编语言都是面向机器结构的语言，统称为<strong>机器级语言</strong></li></ol><ul><li>编译程序(Complier)：将高级语言源程序转换为机器级目 标程序，执行时只要启动目标程序即可 </li><li>解释程序(Interpreter )：将高级语言语句逐条翻译成机器 指令并立即执行，不生成目标文</li></ul><h4 id="1-3-指令集体系结构"><a href="#1-3-指令集体系结构" class="headerlink" title="1.3 指令集体系结构"></a>1.3 指令集体系结构</h4><ul><li>ISA(Instruction Set Architecture)，即<strong>指令集体系结构</strong></li><li>ISA是一种规约</li></ul><h4 id="1-4-冯诺依曼体系结构"><a href="#1-4-冯诺依曼体系结构" class="headerlink" title="1.4 冯诺依曼体系结构"></a>1.4 冯诺依曼体系结构</h4><blockquote><p>1946年，普林斯顿高等研究院（the Institute for Advance Study at Princeton，IAS ）开始设计 <strong>存储程序</strong>计算机，被称为IAS计算机（1951年才完成，并不是第一台存储程序计算机，1949年由英国剑桥大学完成的EDSAC是第一台）。在那个报告中提出的计算机结构被称为冯·诺依曼结构。<br>冯·诺依曼结构最重要的思想是“存储程序(Stored-program)” 工作方式： 任何要计算机完成的工作都要先被编写成程序，然后将程序和原始 数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操 作人员干预下，自动完成逐条取出指令和执行指令的任务</p></blockquote><p>冯诺依曼的主要思想：</p><ol><li>计算机应由运算器、控制器、存储器、输入设备和输出设备 五个基本部件组成。 </li><li><p>各基本部件的功能是： </p><p> • 存储器不仅能存放数据，而且也能存放指令，形式上两者 没有区别，但计算机应能区分数据还是指令；<br> • 控制器应能自动取出指令来执行；<br> • 运算器应能进行加/减/乘/除四种基本算术运算，并且也 能进行一些逻辑运算和附加运算；<br> • 操作人员可以通过输入设备、输出设备和主机进行通信。 </p></li><li><p>内部以二进制表示指令和数据。每条指令由操作码和地址码 两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。 </p></li><li><p>采用“存储程序”工作方式。</p></li></ol><h3 id="2-第二章"><a href="#2-第二章" class="headerlink" title="2. 第二章"></a>2. 第二章</h3><h4 id="2-1-定点数的编码表示"><a href="#2-1-定点数的编码表示" class="headerlink" title="2.1 定点数的编码表示"></a>2.1 定点数的编码表示</h4><blockquote><p>模运算</p></blockquote><ul><li>结论1：一个负数的补码等于模减该负数的绝对值。</li><li>结论2：对于某一确定的模，某数减去小于模的另一数，总可 以用该数加上另一数负数的补码来代替。</li></ul><blockquote><p>补码的表示</p></blockquote><ul><li><p>结论1：一个负数的补码等于将对应正数补码 各位取反、末位加一</p></li><li><p>变形（4’s）补码：双符号，用于存放可能溢出的中间结果</p></li></ul><blockquote><p>求补码的真值：</p><ul><li>简便求法： 符号为0，则为正数，数值部分相同 符号为1，则为负数，数值各位取反，末位加</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;准备自学csapp了，怕听不懂课。知乎说NJU的袁春华老师讲的&lt;strong&gt;计算机系统基础&lt;/strong&gt;特别好，所以准备先学这个好了。&lt;/p&gt;
&lt;h3 id=&quot;1-第一章&quot;&gt;&lt;a href=&quot;#1-第一章&quot; class=&quot;headerlink&quot; title=&quot;1. 第一章&quot;&gt;&lt;/a&gt;1. 第一章&lt;/h3&gt;&lt;h4 id=&quot;1-1-理解&quot;&gt;&lt;a href=&quot;#1-1-理解&quot; class=&quot;headerlink&quot; title=&quot;1.1 理解&quot;&gt;&lt;/a&gt;1.1 理解&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;计算机系统抽象层，从上至下依次是：应用（问题），算法，编程（语言），操作系统/虚拟机，指令集体系结构（ISA），微体系结构，功能部件，电路，器件。&lt;strong&gt;指令集体系结构&lt;/strong&gt;是软件和硬件的交界层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-程序开发和执行过程简介&quot;&gt;&lt;a href=&quot;#1-2-程序开发和执行过程简介&quot; class=&quot;headerlink&quot; title=&quot;1.2 程序开发和执行过程简介&quot;&gt;&lt;/a&gt;1.2 程序开发和执行过程简介&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;指令包含操作码和操作数或其他地址码&lt;/li&gt;
&lt;li&gt;机器语言和汇编语言都是面向机器结构的语言，统称为&lt;strong&gt;机器级语言&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;编译程序(Complier)：将高级语言源程序转换为机器级目 标程序，执行时只要启动目标程序即可 &lt;/li&gt;
&lt;li&gt;解释程序(Interpreter )：将高级语言语句逐条翻译成机器 指令并立即执行，不生成目标文&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-3-指令集体系结构&quot;&gt;&lt;a href=&quot;#1-3-指令集体系结构&quot; class=&quot;headerlink&quot; title=&quot;1.3 指令集体系结构&quot;&gt;&lt;/a&gt;1.3 指令集体系结构&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ISA(Instruction Set Architecture)，即&lt;strong&gt;指令集体系结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ISA是一种规约&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows和manjaro双系统共存引导的解决方法</title>
    <link href="https://blog.fuujiro.com/2018/05/22/Windows%E5%92%8Cmanjaro%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%85%B1%E5%AD%98%E5%BC%95%E5%AF%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.fuujiro.com/2018/05/22/Windows和manjaro双系统共存引导的解决方法/</id>
    <published>2018-05-21T17:35:52.000Z</published>
    <updated>2018-06-12T11:00:36.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Q: What do the <strong>Ninja-fuujiro</strong> do?<br>A: 简单来说，就是替换引导文件。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。</p></blockquote><p>（为什么要替换？因为Manjaro太弱鸡，Windows是攻，我们帮Manjaro一把。我们是平权主义者！拒绝霸道2333！ε=ε=ε=┏(゜ロ゜;)┛</p><h3 id="1-打开Windows-Powershell-Administrator"><a href="#1-打开Windows-Powershell-Administrator" class="headerlink" title="1. 打开Windows Powershell(Administrator)"></a>1. 打开Windows Powershell(Administrator)</h3><ol><li><code>win + x</code></li><li><code>a</code></li></ol><h3 id="2-将grubx64-efi-引导代替掉-bootmgfw-efi"><a href="#2-将grubx64-efi-引导代替掉-bootmgfw-efi" class="headerlink" title="2. 将grubx64.efi 引导代替掉 bootmgfw.efi"></a>2. 将grubx64.efi 引导代替掉 bootmgfw.efi</h3><ul><li>输入   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &apos;&#123;bootmgr&#125;&apos; path \EFI\Manjaro\grubx64.efi</span><br></pre></td></tr></table></figure></li></ul><p>如果不好意思，你的Powershell对你有意见。你可能需要把<code>&#39;{bootmgr}&#39;</code>换成<code>{bootmgr}</code>。原因是可能你没听话，用的是cmd，没见着我说用Powershell了嘛~！</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><blockquote><ul><li><a href="https://blog.itswincer.com/posts/ad42f575/" target="_blank" rel="noopener">Linux 与 Windows 10 用 GRUB 引导教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Q: What do the &lt;strong&gt;Ninja-fuujiro&lt;/strong&gt; do?&lt;br&gt;A: 简单来说，就是替换引导文件。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（为什么要替换？因为Manjaro太弱鸡，Windows是攻，我们帮Manjaro一把。我们是平权主义者！拒绝霸道2333！ε=ε=ε=┏(゜ロ゜;)┛&lt;/p&gt;
&lt;h3 id=&quot;1-打开Windows-Powershell-Administrator&quot;&gt;&lt;a href=&quot;#1-打开Windows-Powershell-Administrator&quot; class=&quot;headerlink&quot; title=&quot;1. 打开Windows Powershell(Administrator)&quot;&gt;&lt;/a&gt;1. 打开Windows Powershell(Administrator)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;win + x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-将grubx64-efi-引导代替掉-bootmgfw-efi&quot;&gt;&lt;a href=&quot;#2-将grubx64-efi-引导代替掉-bootmgfw-efi&quot; class=&quot;headerlink&quot; title=&quot;2. 将grubx64.efi 引导代替掉 bootmgfw.efi&quot;&gt;&lt;/a&gt;2. 将grubx64.efi 引导代替掉 bootmgfw.efi&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;输入   &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bcdedit /set &amp;apos;&amp;#123;bootmgr&amp;#125;&amp;apos; path \EFI\Manjaro\grubx64.efi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不好意思，你的Powershell对你有意见。你可能需要把&lt;code&gt;&amp;#39;{bootmgr}&amp;#39;&lt;/code&gt;换成&lt;code&gt;{bootmgr}&lt;/code&gt;。原因是可能你没听话，用的是cmd，没见着我说用Powershell了嘛~！&lt;/p&gt;
&lt;h3 id=&quot;感谢&quot;&gt;&lt;a href=&quot;#感谢&quot; class=&quot;headerlink&quot; title=&quot;感谢&quot;&gt;&lt;/a&gt;感谢&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.itswincer.com/posts/ad42f575/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 与 Windows 10 用 GRUB 引导教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>尝螃蟹的人，体验Ubuntu 18.04 LTS（仿生河狸）！</title>
    <link href="https://blog.fuujiro.com/2018/04/30/%E5%B0%9D%E8%9E%83%E8%9F%B9%E7%9A%84%E4%BA%BA%EF%BC%8C%E4%BD%93%E9%AA%8CUbuntu-18-04-LTS%EF%BC%88%E4%BB%BF%E7%94%9F%E6%B2%B3%E7%8B%B8%EF%BC%89%EF%BC%81/"/>
    <id>https://blog.fuujiro.com/2018/04/30/尝螃蟹的人，体验Ubuntu-18-04-LTS（仿生河狸）！/</id>
    <published>2018-04-30T01:21:28.000Z</published>
    <updated>2018-06-12T11:00:36.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Ubuntu 18.04 LTS</code>在2018年4月26号准时发布啦！！！当天我还是没挤进去成功下载，国内几大镜像源似乎都爆掉了，直到今天我才把<code>Ubuntu 18.04</code>装在虚拟机上体验了一把！感觉很棒哦，不错嘛~！</p><blockquote><p><code>Ubuntu 18.04 LTS</code> 被 Canonical 创始人 Mark Shuttleworth 命名为<strong>Bionic Beaver，仿生海狸</strong>，这主要是为了纪念 Ubuntu 人孜孜不倦的辛劳工作。所以，以海狸充满活力的态度，勤劳的本性，此次版本更新周期以这种哺乳动物作为吉祥物进行命名。</p></blockquote><p>废话不多说，<code>Ubuntu 18.04 LTS</code>到底带给我们哪些<code>new features</code>呢？到底换不换发行版呢？让我们一起来看看！</p><hr><h3 id="1-Ubuntu-18-04-LTS的闪光点"><a href="#1-Ubuntu-18-04-LTS的闪光点" class="headerlink" title="1. Ubuntu 18.04 LTS的闪光点"></a>1. <code>Ubuntu 18.04 LTS</code>的<code>闪光点</code></h3><h4 id="1-1-GNOME正式抵达"><a href="#1-1-GNOME正式抵达" class="headerlink" title="1.1 GNOME正式抵达"></a>1.1 <code>GNOME</code>正式抵达</h4><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/ubuntu-18.04-LTS/7.PNG" alt="gnome"></p><p>我觉得太tm酷啦！！23333~</p><p>Ubuntu 18.04 LTS 发布的同时也带来了 GNOME 3.28，由于 GNOME 在 Ubuntu 17.10 中已经取代了 Unity（尽管 Unity 并未完全挂掉），因此 GNOME 也已经成为了 Ubuntu 系统默认的桌面环境。</p><p>当然，如果你不喜欢使用 GNOME，其他 Ubuntu 桌面环境也是可用的，如：MATE。</p><p>GNOME 正式来到 Ubuntu 18.04 LTS 桌面也标志着新统一风格定制的 GNOME 3.0 桌面在长期支持版本上得到支持，这也是升级到 Ubuntu 18.04 系统一个很好的理由。</p><h4 id="1-2-全新的图标集"><a href="#1-2-全新的图标集" class="headerlink" title="1.2 全新的图标集"></a>1.2 全新的图标集</h4><blockquote><p>官方宣传图</p></blockquote><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/ubuntu-18.04-LTS/11.png" alt="官宣"></p><blockquote><p>实际图</p></blockquote><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/ubuntu-18.04-LTS/4.PNG" alt="实际"></p><h4 id="1-3-彩色emoji"><a href="#1-3-彩色emoji" class="headerlink" title="1.3 彩色emoji"></a>1.3 彩色<code>emoji</code></h4><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/ubuntu-18.04-LTS/12.jpg" alt="emoji"></p><p>表情符号在个人 Linux 功能愿望清单中需求度可能不会很高，但不能否认表情符号现在是现代数字通信的一个重要组成部分。包括 Fedora 在内的许多其他流行 Linux 发行版很久以前就获得了对 emoji 的支持，在 Ubuntu 18.04 LTS 正式发布时，Ubuntu 用户也终于可以享受桌面应用程序中对彩色表情符号的开箱即用支持了。</p><p>为确保平台之间的一致性， Ubuntu 18.04 LTS 将使用 Noto Color Emoji 字体，该字体支持最新 Unicode 版本中定义的所有表情符号。</p><blockquote><p>怎么安装新的emoji呢?</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fonts-emojione</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt;在2018年4月26号准时发布啦！！！当天我还是没挤进去成功下载，国内几大镜像源似乎都爆掉了，直到今天我才把&lt;code&gt;Ubuntu 18.04&lt;/code&gt;装在虚拟机上体验了一把！感觉很棒哦，不错嘛~！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt; 被 Canonical 创始人 Mark Shuttleworth 命名为&lt;strong&gt;Bionic Beaver，仿生海狸&lt;/strong&gt;，这主要是为了纪念 Ubuntu 人孜孜不倦的辛劳工作。所以，以海狸充满活力的态度，勤劳的本性，此次版本更新周期以这种哺乳动物作为吉祥物进行命名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;废话不多说，&lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt;到底带给我们哪些&lt;code&gt;new features&lt;/code&gt;呢？到底换不换发行版呢？让我们一起来看看！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Ubuntu-18-04-LTS的闪光点&quot;&gt;&lt;a href=&quot;#1-Ubuntu-18-04-LTS的闪光点&quot; class=&quot;headerlink&quot; title=&quot;1. Ubuntu 18.04 LTS的闪光点&quot;&gt;&lt;/a&gt;1. &lt;code&gt;Ubuntu 18.04 LTS&lt;/code&gt;的&lt;code&gt;闪光点&lt;/code&gt;&lt;/h3&gt;&lt;h4 id=&quot;1-1-GNOME正式抵达&quot;&gt;&lt;a href=&quot;#1-1-GNOME正式抵达&quot; class=&quot;headerlink&quot; title=&quot;1.1 GNOME正式抵达&quot;&gt;&lt;/a&gt;1.1 &lt;code&gt;GNOME&lt;/code&gt;正式抵达&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fuujiro/pictures/master/ubuntu-18.04-LTS/7.PNG&quot; alt=&quot;gnome&quot;&gt;&lt;/p&gt;
&lt;p&gt;我觉得太tm酷啦！！23333~&lt;/p&gt;
&lt;p&gt;Ubuntu 18.04 LTS 发布的同时也带来了 GNOME 3.28，由于 GNOME 在 Ubuntu 17.10 中已经取代了 Unity（尽管 Unity 并未完全挂掉），因此 GNOME 也已经成为了 Ubuntu 系统默认的桌面环境。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构-Review！</title>
    <link href="https://blog.fuujiro.com/2018/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Review-%E8%80%83%E8%AF%95%E9%AB%98%E5%88%86%E8%BF%87%EF%BC%81/"/>
    <id>https://blog.fuujiro.com/2018/04/29/数据结构-Review-考试高分过！/</id>
    <published>2018-04-29T02:42:36.000Z</published>
    <updated>2018-06-12T11:00:36.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>复习一下课没好好上过的数据结构，唉！要期末考试噜！数据结构和算法要是想成为<code>Master</code>，好难欸！！~</p><blockquote><p>Q：如何高效率使用这篇总结？<br>A：查看写的所有数据结构的定义，然后戳所有带<code>-&gt; recommend！</code>这个标识的链接，嗯！速度就是这样~认真的话，建议复写所有数据结构的实现代码啦！</p></blockquote><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li><p><a href="#1"><strong>线性表</strong></a><br> 1.1 <a href="#1.1">顺序表示和实现</a><br> 1.2 <a href="#1.2">链式表示和实现</a><br> 1.2.1 <a href="#1.2.1"><code>线性链表</code></a><br> 1.2.2 <a href="#1.2.2"><code>循环链表</code></a><br> 1.2.3 <a href="#1.2.3"><code>双向链表</code></a></p></li><li><p><a href="#2"><strong>栈和队列</strong></a><br> 2.1 <a href="#2.1">栈</a><br> 2.2 <a href="#2.2">队列</a></p></li><li><p><a href="#3"><strong>数组</strong></a><br> 3.1 <a href="#3.1">数组的顺序表示和实现</a><br> 3.2 <a href="#3.2">矩阵的压缩存储</a><br> 3.2.1 <a href="#3.2.1"><code>稀疏矩阵</code></a></p></li><li><p><a href="#4"><strong>树</strong></a><br> 4.1 <a href="#4.1">二叉树</a><br> 4.2 <a href="#4.2">遍历二叉树</a><br> 4.2.1 <a href="#4.2.1"><code>三大遍历的递归实现</code></a><br> 4.2.2 <a href="#4.2.2"><code>三大遍历的非递归实现</code></a><br> 4.2.3 <a href="#4.2.3"><code>层次遍历</code></a><br> 4.3 <a href="#4.3">树和森林</a><br> 4.3.1 <a href="#4.3.1"><code>数和森林的存储结构</code></a><br> 4.3.2 <a href="#4.3.2"><code>数和森林的遍历</code></a><br> 4.4 <a href="4.4">赫夫曼树</a></p></li><li><p><a href="#5"><strong>图</strong></a><br> 5.1 <a href="#5.1">图的定义</a><br> 5.2 <a href="#5.2">图的存储结构</a><br> 5.2.1 <a href="#5.2.1"><code>邻接表</code></a><br> 5.2.2 <a href="#5.2.2"><code>十字链表</code></a><br> 5.3 <a href="#5.3">图的遍历</a><br> 5.3.1 <a href="#5.3.1"><code>深度优先搜索</code></a><br> 5.3.2 <a href="#5.3.2"><code>广度优先搜索</code></a><br> 5.4 <a href="#5.4">图的连通性</a><br> 5.4.1 <a href="#5.4.1"><code>最小生成树</code></a><br> 5.5 <a href="#5.5">拓扑排序</a><br> 5.6 <a href="#5.6">最短路径</a><br> 5.6.1 <a href="#5.6.1"><code>Dijkstra算法</code></a></p></li><li><p><a href="#6"><strong>查找</strong></a><br> 6.1 <a href="#6.1">静态查找</a><br> 6.1.1 <a href="#6.1.1"><code>顺序查找</code></a><br> 6.1.2 <a href="#6.1.2"><code>二分查找</code></a><br> 6.2 <a href="#6.2">动态查找</a><br> 6.2.1 <a href="#6.2.1"><code>二叉排序树</code></a><br> 6.3 <a href="#6.3">哈希表</a></p></li><li><p><a href="#7"><strong>内部排序</strong></a><br> 7.1 <a href="#7.1">插入排序</a><br> 7.1.1 <a href="#7.1.1"><code>直接插入排序</code></a><br> 7.1.2 <a href="#7.1.2"><code>折半插入排序</code></a><br> 7.1.3 <a href="#7.1.3"><code>希尔排序</code></a><br> 7.2 <a href="#7.2">交换排序</a><br> 7.2.1 <a href="#7.2.1"><code>冒泡排序</code></a><br> 7.2.2 <a href="#7.2.2"><code>快速排序</code></a><br> 7.3 <a href="#7.3">选择排序</a><br> 7.3.1 <a href="#7.3.1"><code>简单选择排序</code></a><br> 7.3.2 <a href="#7.3.2"><code>堆排序</code></a><br> 7.4 <a href="#7.4">归并排序</a></p></li></ol><hr><h3 id="1"> 1. 线性表 </h3><blockquote><p>线性表<code>Linear_list</code>是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。</p></blockquote><h4 id="1.1"> 1.1 顺序表示和实现 </h4><blockquote><p>线性表的顺序表示<code>Sequential List</code>指的是用一组地址连续的储存单元依次储存线性表的数据元素。<code>顺序储存结构</code>是一种随机存取的储存结构。通常用<code>数组</code>来描述顺序储存结构。</p></blockquote><p>C语言用动态分配的一维数组，来描述线性表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">//线性表储存空间的初始分配量</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10 <span class="comment">//线性表的分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem;  <span class="comment">// 储存空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//当前线性表的长度</span></span><br><span class="line">    <span class="keyword">int</span> listsize; <span class="comment">//当前分配的储存容量</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><blockquote><p>更多有关线性表的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/bruthyu/article/details/52645510" target="_blank" rel="noopener">线性表与13个基本操作的实现</a></li></ul></blockquote><h4 id="1.2"> 1.2 链式表示和实现 </h4><blockquote><p>链式储存结构<code>Linked List</code>与顺序储存结构<code>Sequential List</code>的不同：顺序储存结构的特点是逻辑关系上两个相邻元素在物理位置上也相同，这样随机存取任意元素很快很直观，缺点是需要移动大量其他元素。而链式结构，它不要求逻辑上相邻的元素在物理位置上相邻，因此它存取元素不需要移动其他元素，但是对于查找元素有心无力。</p></blockquote><h5 id="1.2.1"> 1.2.1 线性链表 </h5><blockquote><p>可以理解为单向链表<code>Singly Linked List</code>，单向链表是非随机存取结构。</p></blockquote><p>一些常用的方法：</p><ul><li><p>添加元素（s是指向待添加节点的指针）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure></li><li><p>删除元素（a,b,c是链表中相连的3个结点，b是待删除的结点，现在p是指向a结点的指针）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure></li></ul><p>用结构体实现链表结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的单链表储存结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>更多链表知识，请戳：</p><ul><li><a href="https://blog.csdn.net/21aspnet/article/details/160019" target="_blank" rel="noopener">C语言单向链表的实现</a></li><li><a href="https://blog.csdn.net/lan74__/article/details/53819849" target="_blank" rel="noopener">链表的基本使用一（构建链表）</a></li><li><a href="https://blog.csdn.net/juanqinyang/article/details/51351619" target="_blank" rel="noopener">数据结构：链表(linked-list)</a></li></ul></blockquote><h5 id="1.2.2"> 1.2.2 循环链表 </h5><ol><li><p>循环单链表特点：</p><p> 链表中最后一个结点的指针域不再是结束标志，而是指向整个链表的第一个结点，从而使链表形成一个环。和单链表相同，循环单链表也有带头结点和不带头结点两种。带头结点的循环单链表实现插入和删除操作较为方便，且更加适用。</p></li><li><p>单链表与循环单链表比较：</p><p> 循环单链表可以从尾到头，而单链表不能从尾到头。因此处理的数据序列具有环形结构特点时，适合采用循环单链表。</p></li><li><p>带头结点的循环单链表和带头结点的单链表比较：</p><p> ① 在初始化函数中，把语句<code>head-&gt;next=NULL</code>改为<code>head-&gt;next = head</code>，即形成一个环<br> ② 在其他函数中，循环判断条件<code>p-&gt;next!=NULL</code>和<code>p-&gt;next-&gt;next!=NULL</code>中的NULL改成头指针<code>head</code>。</p></li></ol><h5 id="1.2.3"> 1.2.3 双向链表 </h5><ol><li><p>双向链表特点：<br> 每个节点除了有后继指针域还有一个前驱指针域。</p></li><li><p>双向链表的分类：<br> 双向链表有：带头结点和不带头结点的双向链表（但是带头结点的双向链表更为常用）。也有循环和非循环之分，循环结构的双向链表更为常用。因此下面讨论的是带头结点的循环双链表。</p></li><li><p>双向循环链表结点的结构体定义</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的双向链表储存结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> &#123;</span></span><br><span class="line">    Elemtype data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span> <span class="comment">//前驱结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span>  <span class="comment">//后继结点</span></span><br><span class="line">&#125;DuLNode， *DuLinklist;</span><br></pre></td></tr></table></figure><p> <strong>备注</strong>：data域、next域、prior域。其中data域是数据域，next域为指向后继结点的指针域，prior域为指向前驱结点的指针域。</p></li><li><p>双向链表的优点：<br> 在单链中查找当前结点的后继结点并不困难，可以通过当前结点的next指针进行，但要查找当前结点的前驱结点，就要从头指针head开始重新进行。对于一个要频繁进行当前结点的后继结点和前驱结点的应用来说，使用双向链表很有效。</p></li><li><p>双向循环链表的实现<br> 在双向链表中，有如下指针关系：设指针p指向双向循环链表中的第i个位置，则<code>p-&gt;next</code>指向i+1个结点。<code>p-&gt;next-&gt;prior</code>仍指向第i个结点，即<code>p-&gt;next-&gt;prior==p</code>;同样<code>p-&gt;prior</code>指向第i-1个结点，<code>p-&gt;prior-&gt;next</code>仍指向第i个结点，即<code>p-&gt;prior-&gt;next==p</code>;双向循环链表关系算法可以方便算法设计。</p></li></ol><blockquote><p>更多循环链表和双向链表的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/xiaofei__/article/details/50984255" target="_blank" rel="noopener">数据结构——循环单链表和双向链表</a></li><li><a href="http://www.cnblogs.com/hughdong/p/6785391.html" target="_blank" rel="noopener">数据结构 | 双向链表简单实现及图示</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h3 id="2"> 2. 栈和队列 </h3><p>从数据结构上看，栈和队列也是线性表。不过他们是操作受限的线性表，因此，称它们为限定性的数据结构。</p><h4 id="2.1"> 2.1 栈 </h4><p>栈<code>stack</code>是限定仅在表尾进行插入和删除的线性表。对于栈，表尾称为<code>栈顶</code>，相应地，表头称为<code>栈底</code>。不含元素的空表称为<code>空栈</code>。栈是一种后进先出（last in first out, LIFO）结构。</p><p>栈有两种储存方式，顺序栈和链式栈。</p><p>顺序栈的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：<code>stacksize</code>指当前可使用的最大容量，<code>base</code>表示栈底指针，<code>base</code>为NULL时，表明栈结构不存在，其初值指向栈底，即<code>top = base</code>可作为栈空的标记。插入元素，top+1；删除元素，top-1。</p><blockquote><p>更多栈的知识，请戳：</p><ul><li><a href="https://www.cnblogs.com/racaljk/p/7822309.html" target="_blank" rel="noopener">[数据结构]C语言栈的实现</a></li><li><a href="https://www.cnblogs.com/QG-whz/p/5170418.html" target="_blank" rel="noopener">数据结构图文解析之：栈的简介及C++模板实现</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h4 id="2.2"> 2.2 队列 </h4><p>和栈相反，队列<code>quene</code>是一种先进先出（first in first out, FIFO）的线性表，它只允许在表的一端插入，另一端删除。在队列中，允许插入的一端叫做队尾<code>rear</code>，允许删除的一端叫做队头<code>front</code>。</p><p>队列也有两种储存方式，顺序队列和链队列。</p><p>链队列的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QuenePtr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkQuene</span> &#123;</span></span><br><span class="line">    QuenePtr front; <span class="comment">//队头指针</span></span><br><span class="line">    QuenePtr rear; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQuene;</span><br></pre></td></tr></table></figure><blockquote><p>更多队列知识，请戳：</p><ul><li><a href="https://blog.csdn.net/juanqinyang/article/details/51354293" target="_blank" rel="noopener">数据结构-队列(queue)</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h3 id="3"> 3. 数组 </h3><p>数组和广义表可以看作是线性表的扩展，也算是一种数据结构。</p><h4 id="3.1"> 3.1 数组的顺序表示和实现 </h4><p>由于数组一般不做插入或删除操作，因此采用顺序储存结构表示数组是最吼滴！</p><blockquote><p>假设每个数据元素占$L$个存储单元，则二维数组$A$中任一元素$aij$的存储位置可由下式确定：$LOC(i, j) = LOC(0, 0) + (b_2*i + j)L$</p></blockquote><p>数组的顺序存储的表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_DIM 8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    ElemType *base;</span><br><span class="line">    <span class="keyword">int</span> dim;</span><br><span class="line">    <span class="keyword">int</span> *bounds;</span><br><span class="line">    <span class="keyword">int</span> *constants;</span><br><span class="line">&#125;Array;</span><br></pre></td></tr></table></figure><h4 id="3.2"> 3.2 矩阵的压缩存储 </h4><p>压缩存储指的是为多个值相同的元只分配一个存储单元；对零元不分配空间。</p><blockquote><p>更多压缩存储的知识，请戳：</p><ul><li><a href="https://www.cnblogs.com/zhang01010/p/7749339.html" target="_blank" rel="noopener">对称矩阵的压缩</a></li></ul></blockquote><h5 id="3.2.1"> 3.2.1 稀疏矩阵 </h5><blockquote><p>对于那些零元素数目远远多于非零元素数目，并且非零元素的分布没有规律的矩阵称为稀疏矩阵（sparse）。</p></blockquote><ul><li>由于非零元素分布没有任何规律，所以在进行压缩存储的时侯需要存储非零元素值的同时还要存储非零元素在矩阵中的位置，即非零元素所在的行号和列号，也就是在存储某个元素比如$aij$的值的同时，还需要存储该元素所在的行号$i$和它的列号$j$，这样就构成了一个三元组$(i,j,aij)$的线性表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 12500</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">triple</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j; <span class="comment">// 该非零元的行下标和列下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsmatrix</span> &#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>]; <span class="comment">//非零元三元组</span></span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu; <span class="comment">//行数，列数，非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure><blockquote><p>更多稀疏矩阵的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/sunhuaqiang1/article/details/51296803" target="_blank" rel="noopener">稀疏矩阵</a></li></ul></blockquote><h3 id="4"> 4. 树 </h3><blockquote><p>树状图是一种数据结构，它是由$n$（$n&gt;=1$）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点（除了根节点外，每个子节点可以分为多个不相交的子树）</li></ul></blockquote><h4 id="4.1"> 4.1 二叉树 </h4><blockquote><p>二叉树<code>Binary Tree</code>是另一种树型结构，它的特点是每个结点至多有$2$棵子树（即二叉树中不存在度大于$2$的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p></blockquote><p>二叉树的性质：</p><ul><li>在二叉树的第$i$层上至多有$2^(i-1)$个结点（$i&gt;=1$）。</li><li>深度为$k$的二叉树至多有$2^k - 1$个结点（$K&gt;=1$）。</li><li>对任何一棵二叉树$T$，如果其终端结点数为$n_0$，度为$2$的结点树为$n_2$，则$n_0=n_2+1$。</li><li>具有$n$个结点的完全二叉树的深度为|$\log_2 n$| + 1。（|$\log_2 n$|表示不大于$\log_2 n$的最大整数）</li><li>如果对一棵有$n$个结点的完全二叉树（其深度为|$\log_2 n$| + 1）的结点按层序编号（从第$1$层到第|$\log_2 n$| + $1$层，每层从左到右），则对任一结点$i$（$1 &lt;= i &lt;= n$），有：<ol><li>如果$i = 1$，则结点$i$是二叉树的根，无双亲；如果$i &gt; 1$，则其双亲<code>PARENT(i)</code>是结点|$i/2$|。</li><li>如果$2i &gt; n$，则结点$i$无左孩子（即结点i为叶子结点）；否则其左孩子<code>LCHILD(i)</code>是结点$2$。</li><li>如果$2i + 1 &gt; n$，则结点$i$无右孩子；否则其右孩子<code>RCHILD(i)</code>是结点$2i+1$。</li></ol></li></ul><p>二叉树的顺序储存结构（仅适用于完全二叉树）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">// 二叉树的最大结点树</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">// 0号单元存储根节点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><p>二叉树的链式存储结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTree</span> &#123;</span></span><br><span class="line">    TElemType data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTree</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTree, *BiTree;</span><br></pre></td></tr></table></figure><blockquote><p>更多二叉树知识，请戳：</p><ul><li><a href="https://www.cnblogs.com/yeqluofwupheng/p/7428935.html" target="_blank" rel="noopener">二叉树总结(一)概念和性质</a></li><li><a href="https://blog.csdn.net/wireless_com/article/details/70596155" target="_blank" rel="noopener">markdown中的数学公式简要</a></li></ul></blockquote><h4 id="4.2"> 4.2 遍历二叉树 </h4><blockquote><p>二叉树是一种非线性结构，是由3个基本单元组成：根节点，左子树和右子树。规定先左后右，有3种基本情况，先序遍历，中序遍历和后序遍历。</p></blockquote><h5 id="4.2.1"> 4.2.1 三大遍历的递归实现 </h5><ul><li><p>先序遍历（根-左-右）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder1</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRoot-&gt;value;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">NULL</span>)  </span><br><span class="line">        preOrder1(pRoot-&gt;left);  </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">NULL</span>)  </span><br><span class="line">        preOrder1(pRoot-&gt;right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历（左-根-右）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder1</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;left!=<span class="literal">NULL</span>)  </span><br><span class="line">        inOrder1(pRoot-&gt;left);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRoot-&gt;value;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;right!=<span class="literal">NULL</span>)  </span><br><span class="line">        inOrder1(pRoot-&gt;right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历（左-右-根）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder1</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    postOrder1(pRoot-&gt;left);  </span><br><span class="line">    postOrder1(pRoot-&gt;right);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pRoot-&gt;value&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4.2.2"> 4.2.2 三大遍历的非遍历实现 </h5><ul><li><p>先序遍历（根-左-右）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; s;  </span><br><span class="line">    BinaryTreeNode *p=pRoot;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;value&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">            s.push(p);  </span><br><span class="line">            p=p-&gt;left;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(!s.empty())  </span><br><span class="line">        &#123;  </span><br><span class="line">            p=s.top();  </span><br><span class="line">            s.pop();  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历（左-根-右）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; s;  </span><br><span class="line">    BinaryTreeNode *p=pRoot;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            s.push(p);  </span><br><span class="line">            p=p-&gt;left;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(!s.empty())  </span><br><span class="line">        &#123;  </span><br><span class="line">            p=s.top();  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;value;  </span><br><span class="line">            s.pop();  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历（左-右-根）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; s;  </span><br><span class="line">    BinaryTreeNode *cur;  </span><br><span class="line">    BinaryTreeNode *pre=<span class="literal">NULL</span>;  </span><br><span class="line">    s.push(pRoot);<span class="comment">//根结点入栈  </span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cur=s.top();  </span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;left==<span class="literal">NULL</span>&amp;&amp;cur-&gt;right==<span class="literal">NULL</span>)||(pre!=<span class="literal">NULL</span>&amp;&amp;(pre==cur-&gt;left||pre==cur-&gt;right)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//左孩子和右孩子同时为空，或者当前结点的左孩子或右孩子已经遍历过了  </span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;value&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">            s.pop();  </span><br><span class="line">            pre=cur;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">NULL</span>)  </span><br><span class="line">                s.push(cur-&gt;right);  </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">NULL</span>)  </span><br><span class="line">                s.push(cur-&gt;left);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4.2.3"> 4.2.3 层次遍历 </h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFromTopToBottom</span><span class="params">(BinaryTreeNode* pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;BinaryTreeNode *&gt; dequeTreeNode;  </span><br><span class="line">  </span><br><span class="line">    dequeTreeNode.push_back(pRoot);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(dequeTreeNode.size())  </span><br><span class="line">    &#123;  </span><br><span class="line">        BinaryTreeNode *pNode = dequeTreeNode.front();  </span><br><span class="line">        dequeTreeNode.pop_front();  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pNode-&gt;m_nValue);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pLeft)  </span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pLeft);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;m_pRight)  </span><br><span class="line">            dequeTreeNode.push_back(pNode-&gt;m_pRight);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多二叉树的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/xiaominkong123/article/details/51567437" target="_blank" rel="noopener">二叉树的四种遍历的递归和非递归的实现</a> -&gt; <em>recommend</em>！</li><li><a href="https://blog.csdn.net/lieacui/article/details/52453292" target="_blank" rel="noopener">二叉树三种遍历方式的递归和循环实现</a></li></ul></blockquote><h4 id="4.3"> 4.3 树和森林 </h4><h5 id="4.3.1"> 4.3.1 树的存储结构 </h5><blockquote><p>双亲表示法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> &#123;</span> <span class="comment">// 结点结构</span></span><br><span class="line">    TElemType data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">int</span> parent; <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// 树结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE]; </span><br><span class="line">    <span class="keyword">int</span> r, n; <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：求结点的孩子时需要遍历整个结构。</p><blockquote><p> 孩子表示法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span> <span class="comment">// 孩子结点</span></span><br><span class="line">    <span class="keyword">int</span> child; </span><br><span class="line">    sturct CTNode *next;</span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild; <span class="comment">// 孩子链表头结点</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r; <span class="comment">// 结点数的根的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>孩子兄弟表示法（可以把复杂的树变成二叉树）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span> <span class="comment">// 第一个孩子结点和下一个兄弟结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4.3.2"> 4.3.2 树和森林的遍历 </h5><p>当二叉链表作为树的储存结构时，树的<strong>先根遍历</strong>和<strong>后根遍历</strong>类似于二叉树的<strong>先序遍历</strong>和<strong>中序遍历</strong>实现。</p><p>森林一般只说<strong>先序遍历</strong>和<strong>中序遍历</strong>，和二叉树的<strong>先序遍历</strong>和<strong>中序遍历</strong>相同。</p><blockquote><p>更多树和森林的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/qq_36016407/article/details/55272598" target="_blank" rel="noopener">树的存储结构和代码实现</a></li><li><a href="https://blog.csdn.net/wangzi11322/article/details/45391157" target="_blank" rel="noopener">树和森林的遍历</a></li></ul></blockquote><h4 id="4.4"> 4.4 赫夫曼树 </h4><blockquote><p>赫夫曼树<code>Huffman</code>，又称最优二叉树，是一类带权路径长度最短的树。树的路径长度为树中所有叶子结点的带权路径长度之和。通常记作$WPL=\sum_{k=0}^{n}\omega_k\iota_k$ 。</p></blockquote><p>假设有n个权值，构造一棵有n个叶子结点的二叉树，每个叶子结点带权为$\omega_i$，则其中带权路径长度$WPL$最小的二叉树称为<strong>赫夫曼树</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> weight; <span class="comment">// 权重</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> parent, lchild, rchild; </span><br><span class="line">&#125;HTNode, *HuffmanTree; <span class="comment">// 动态分配数组存储赫夫曼树</span></span><br></pre></td></tr></table></figure><blockquote><p>更多赫夫曼树的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/wo16fafafa/article/details/52420007" target="_blank" rel="noopener">哈夫曼树</a></li><li><a href="https://www.cnblogs.com/nathaneko/p/6497982.html" target="_blank" rel="noopener">基础数据结构-二叉树-赫夫曼树的解码</a></li></ul></blockquote><h3 id="5"> 5. 图 </h3><blockquote><p><strong>图</strong><code>Graph</code>是一种较线性表和树更为复杂的数据结构。在<strong>线性表</strong>中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在<strong>树</strong>形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层的多个元素（即孩子结点）相关，但只和上一层的一个元素（即双亲结点）相关。而在<strong>图</strong>形结构中，结点之间的关系是任意的。</p></blockquote><h4 id="5.1"> 5.1 图的定义 </h4><p>在图中，数据元素称为<strong>顶点</strong>，$V$是顶点的有穷非空集合；$VR$是两个顶点之间的关系集合。</p><ul><li>若$&lt;v,w&gt;\epsilon VR$,则$&lt;v,w&gt;$表示从$v$到$w$的一条<strong>弧</strong><code>Arc</code>，且称$v$为<strong>弧尾</strong><code>Tail</code>or<strong>初始点</strong>，$w$为<strong>弧头</strong><code>Head</code>or<strong>终端点</strong>。此时的图称为<strong>有向图</strong><code>Digraph</code>。</li></ul><p>$$G_1 = (V_1,{A_1})$$</p><ul><li>若$&lt;v,w&gt;\epsilon VR$，必有$&lt;w,v&gt;\epsilon VR$，即$VR$是对称的，则以无序对$(v,w)$代替这两个有序对，表示$v$和$w$之间的一条<strong>边</strong><code>Edge</code>，此时的图称为<strong>无向图</strong><code>Undigraph</code>。</li></ul><p>$$G_2 = (V_2,{E_2})$$</p><h4 id="5.2"> 5.2 图的存储结构 </h4><blockquote><p>图的结构较为复杂，常用的存储结构有<strong>邻接表</strong>，<strong>十字链表</strong>。</p></blockquote><h5 id="5.2.1"> 5.2.1 邻接表 </h5><blockquote><p><strong>邻接表</strong><code>Adjacency List</code>是图的一种链式存储结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">// 该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span> <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    InfoType *info; <span class="comment">// 该弧相关信息的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data; <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstarc; <span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">    <span class="keyword">int</span> kind; <span class="comment">// 图的种类标志</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure><h5 id="5.2.2"> 5.2.2 十字链表 </h5><blockquote><p><strong>十字链表</strong><code>Orthogonal List</code>是有向图的另一种链式存储结构。可以看作是将有向图的邻接表和逆邻接表结合起来的一种链表。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tailvex, headvex; <span class="comment">// 该弧的尾和头顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcBox</span> *<span class="title">hlink</span>, *<span class="title">tlink</span>;</span> <span class="comment">// 分别为弧头相同和弧尾相同的弧的链域</span></span><br><span class="line">    InfoType *info; <span class="comment">// 该弧相关的信息的指针</span></span><br><span class="line">&#125;ArcBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span> &#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcBox *firstin, *firstout; <span class="comment">// 分别指向该顶点的第一条入弧和出弧</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VexNode xlist[MAX_VERTEX_NUM]; <span class="comment">// 表头向量</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum; <span class="comment">// 有向图的当前顶点数和弧数</span></span><br><span class="line">&#125;OLGraph;</span><br></pre></td></tr></table></figure><blockquote><p>更多关于图的存储的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/u010366748/article/details/50790324" target="_blank" rel="noopener">数据结构(16)–图的存储及实现</a></li><li><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6905416.html" target="_blank" rel="noopener">图的存储结构之邻接表(详解)</a></li><li><a href="https://blog.csdn.net/wr_technology/article/details/51909432" target="_blank" rel="noopener">图的存储 ( 十字链表 )</a> -&gt; <em>recommend</em>！</li><li><a href="https://www.cnblogs.com/zyl905487045/p/7815429.html" target="_blank" rel="noopener">十字链表的画法</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h4 id="5.3"> 5.3 图的遍历 </h4><blockquote><p><strong>图的遍历</strong><code>Traversing Graph</code>指从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。</p></blockquote><h5 id="5.3.1"> 5.3.1 深度优先搜索 </h5><blockquote><p><strong>深度优先搜索</strong><code>Depth_First Search</code>遍历类似于树的<strong>先根遍历</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    visitFunc(v); <span class="comment">// 访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstAdjVex(G,v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS(G,w); <span class="comment">// 对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5.3.2"> 5.3.2 广度优先搜索 </h5><blockquote><p><strong>广度优先搜索</strong><code>Breadth_First Search</code>遍历类似于树的<strong>层次遍历</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void BFSTraverse(Graph G, Status(*visit)(int v)) &#123;</span><br><span class="line">    <span class="comment">// 按广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">    InitQuene(Q); <span class="comment">// 置空的辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) &#123; <span class="comment">// v尚未访问</span></span><br><span class="line">            visited[v] = TRUE;</span><br><span class="line">            Visit(v);</span><br><span class="line">            Enquene(Q, v); <span class="comment">// v入队列</span></span><br><span class="line">            <span class="keyword">while</span>(!QueneEmpty(Q)) &#123;</span><br><span class="line">                DeQuene(Q, u); <span class="comment">// 队头元素出列并置为0</span></span><br><span class="line">                <span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))</span><br><span class="line">                    <span class="keyword">if</span>(!Visited[w]) &#123; <span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">                        Visited[w] = TRUE;</span><br><span class="line">                        Visit(w);</span><br><span class="line">                        EnQuene(Q, W);</span><br><span class="line">                    &#125; <span class="comment">// if</span></span><br><span class="line">            &#125; <span class="comment">//while</span></span><br><span class="line">        &#125; <span class="comment">// if</span></span><br><span class="line">&#125; <span class="comment">// BFSTraverse</span></span><br></pre></td></tr></table></figure><p>遍历图的过程实质上是通过边或弧找邻接点的过程，因此广度优先搜索和深度优先搜索地<strong>时间复杂度</strong>相同。</p><blockquote><p>更多关于图的遍历的知识，请戳：</p><ul><li><a href="https://www.cnblogs.com/George1994/p/6399889.html" target="_blank" rel="noopener">图的深度优先遍历和广度优先遍历理解</a></li><li><a href="https://www.cnblogs.com/0kk470/p/7555033.html" target="_blank" rel="noopener">数据结构和算法总结（一）：广度优先搜索BFS和深度优先搜索DFS</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h4 id="5.4"> 5.4 图的连通性问题 </h4><blockquote><p>对于连通图来说，从任一顶点出发，便可访问图中所有顶点。而对于非连通地图，则需从多个顶点出发进行搜索。</p></blockquote><h5 id="5.4.1"> 5.4.1 最小生成树 </h5><p>关于图的几个概念定义：</p><ul><li>连通图：在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。</li><li>强连通图：在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。</li><li>连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li><li>生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li><li>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</li></ul><blockquote><p><strong>最小生成树</strong><code>Minimum Cost Spanning Tree</code>指构造连通网的最小代价生成树。</p></blockquote><ul><li><strong>Kruskal算法</strong></li></ul><blockquote><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p></blockquote><ol><li>把图中的所有边按代价从小到大排序； </li><li>把图中的n个顶点看成独立的n棵树组成的森林； </li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><ul><li><strong>Prim算法</strong></li></ul><blockquote><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p></blockquote><ol><li>图的所有顶点集合为V；初始令集合u={s},v=V−u;</li><li>在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ol><p>由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> vertexData   <span class="comment">//表示u中顶点信息</span></span><br><span class="line">    UINT lowestcost   <span class="comment">//最小代价</span></span><br><span class="line">&#125;closedge[vexCounts]</span><br></pre></td></tr></table></figure><blockquote><p>更多关于最小生成树的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">算法导论–最小生成树（Kruskal和Prim算法）</a> -&gt; <em>recommend</em>！</li></ul></blockquote><h4 id="5.5"> 5.5 拓扑排序 </h4><blockquote><p><strong>拓扑排序</strong><code>Topological Sort</code>指由某个集合上的一个偏序得到该集合上的一个全序。</p></blockquote><p>拓扑排序的实现步骤:</p><ol><li>在有向图中选一个没有前驱的顶点并且输出。</li><li>从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）。</li><li>重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的。</li></ol><p>因此，也可以通过拓扑排序来判断一个图是否有环。</p><blockquote><p>更多关于拓扑排序的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/qq_35644234/article/details/60578189" target="_blank" rel="noopener">数据结构—拓扑排序详解</a></li></ul></blockquote><h4 id="5.6"> 5.6 最短路径 </h4><blockquote><p><strong>最短路径</strong>指从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径.</p></blockquote><h5 id="5.6.1"> 5.6.1 Dijkstra算法 </h5><blockquote><p>算法特点：迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p></blockquote><ul><li>算法的思路</li></ul><ol><li>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 </li><li>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， </li><li>然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 </li><li>然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点</li></ol><blockquote><p>更多关于最短路径的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解</a></li></ul></blockquote><h3 id="6"> 6. 查找 </h3><blockquote><p><strong>查找</strong><code>Search</code>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。分类有<strong>静态查找</strong>和<strong>动态查找</strong>。</p></blockquote><ul><li>注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</li></ul><h4 id="6.1"> 6.1 静态查找 </h4><h5 id="6.1.1"> 6.1.1 顺序查找 </h5><ol><li>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</li><li>基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</li><li>复杂度分析：</li></ol><ul><li>查找成功的平均查找长度为（假设每个数据元素的概率相等）: $$ASL = 1/n(1+2+3+…+n) = (n+1)/2$$</li><li>当查找不成功时，需要$n+1$次比较，时间复杂度为$O(n)$；所以，顺序查找的时间复杂度为$O(n)$。</li></ul><blockquote><p>C++实现源码：</p></blockquote><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="6.1.2"> 6.1.2 二分查找（折半查找） </h5><ol><li>说明：元素必须是<strong>有序</strong>的，如果是无序的则要先进行排序操作。</li><li>基本思想：也称为是折半查找，属于<strong>有序查找算法</strong>。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</li><li>折半查找的平均查找长度：$$ASL_{bs} = \frac{1}{n}\sum_{i=1}^{n}{j\times2^{j-1}} = \frac{n+1}{n}\log_2(n+1) - 1 = \log_2(n+1) - 1 $$</li><li>复杂度分析：最坏情况下，关键词比较次数为$\log_2(n+1)$，且期望时间复杂度为$O(log_2n)$；</li></ol><ul><li>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</li></ul><blockquote><p>C++实现源码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找（折半查找），非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多查找算法，请戳：</p><ul><li><a href="https://blog.csdn.net/sayhello_world/article/details/77200009" target="_blank" rel="noopener">数据结构–七大查找算法总结</a></li><li><a href="https://blog.csdn.net/u013036274/article/details/49176027" target="_blank" rel="noopener">【数据结构】静态查找之分块查找</a></li></ul></blockquote><h4 id="6.2"> 6.2 动态查找 </h4><blockquote><p>动态查找：当查找表以顺序存储结构存储且需要保持有序时，若对查找表进行插入、删除或排序操作，就必须移动大量的记录，当记录数很多时，这种移动的代价很大。 若查找表无序，则插入删除可无需移动大量记录，但于查找不利。 利用树的形式组织查找表，可以对查找表进行动态高效的查找。</p></blockquote><h5 id="6.2.1"> 6.2.1 二叉排序树 </h5><p><strong>二叉排序树</strong><code>Binary Sort Tree</code>的定义为：二叉排序树或者是空树，或者是满足下列性质的二叉树。</p><ol><li>若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值； </li><li>若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值； </li><li>左、右子树都分别是二叉排序树。 </li></ol><ul><li>二叉排序树性能</li></ul><ol><li>二叉排序树查找关键字的比较次数，等于该结点所在的层次数（查找成功）； 若查找不成功，其比较次数最多为树的深度。</li><li>对于一棵具有n个结点的树来说，其深度介$log_2(n+1)$与$n$之间。 </li><li>二叉排序树的形态对于查找效率至关重要，或者说，一棵二叉排序树不一定就能提高查找的速度，而是要看这棵树的形态。</li></ol><p><strong>注</strong>：若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。</p><blockquote><p>更多动态查找的知识，请戳：</p><ul><li><a href="https://www.2cto.com/database/201505/396663.html" target="_blank" rel="noopener">数据结构-动态查找</a></li><li><a href="https://blog.csdn.net/jerryburning/article/details/46636479" target="_blank" rel="noopener">查找算法总结之二（动态查找表）</a></li></ul></blockquote><h4 id="6.3"> 6.3 哈希表 </h4><blockquote><p>散列表（<code>Hash table</code>，也叫<strong>哈希表</strong>），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p></blockquote><blockquote><p>哈希表是一种通过哈希函数将特定的键映射到特定值的一种数据结构，他维护者键和值之间一一对应关系。</p></blockquote><ol><li>键(key)：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分。</li><li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li><li>哈希函数(hash function)：将键(key)映射(map)到数据应该存放的槽(slot)所在位置的函数。</li><li>哈希冲突(hash collision)：哈希函数将两个不同的键映射到同一个索引的情况。</li></ol><blockquote><p>更多哈希表的知识，请戳：</p><ul><li><a href="https://www.jianshu.com/p/dbe7a1ea5928" target="_blank" rel="noopener">浅谈哈希表(HashTable)</a> -&gt; <em>recommend</em>！</li><li><a href="http://baijiahao.baidu.com/s?id=1580022096840800840&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">程序员常说的「哈希表」是个什么鬼?</a></li></ul></blockquote><h3 id="7"> 7. 内部排序 </h3><blockquote><p><strong>内部排序</strong>指待排序记录存放在计算机随机存储器（如内存）中进行的排序过程。<br><strong>外部排序</strong>指待排序记录的数量很大，以致于内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</p></blockquote><p>注：我们常常用到的是<strong>内部排序</strong>。</p><h4 id="7.1"> 7.1 插入排序 </h4><h5 id="7.1.1"> 7.1.1 直接插入排序 </h5><ul><li>介绍</li></ul><p><strong>直接插入排序</strong><code>Straight Insertion Sort</code>是基于比较的排序。所谓的基于比较，就是通过比较数组中的元素，看谁大谁小，根据结果来调整元素的位置。</p><p>因此，对于这类排序，就有两种基本的操作：①比较操作； ②交换操作</p><p>其中，对于交换操作，可以优化成移动操作，即不直接进行两个元素的交换，还是用一个枢轴元素(tmp)将当前元素先保存起来，然后执行移动操作，待确定了最终位置后，再将当前元素放入合适的位置。（下面的插入排序就用到了这个技巧）–因为，交换操作需要三次赋值，而移动操作只需要一次赋值！</p><p>有些排序算法，比较次数比较多，而移动次数比较少，而有些则相反。比如，归并排序和快速排序，前者移动次数比较多，而后者比较次数比较多。</p><ul><li>复杂度分析</li></ul><p>插入排序在实现上，通常采用in-place排序（即只需用到$O(1)$的空间复杂度和$O(N^2)$的时间复杂度）），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertsort1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//为a[i]在前面的a[0...i-1]有序区间中找一个合适的位置  </span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)  </span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//如找到了一个合适的位置  </span></span><br><span class="line">        <span class="keyword">if</span> (j != i - <span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//将比a[i]大的数据向后移  </span></span><br><span class="line">            <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">            <span class="keyword">for</span> (k = i - <span class="number">1</span>; k &gt; j; k--)  </span><br><span class="line">                a[k + <span class="number">1</span>] = a[k];  </span><br><span class="line">            <span class="comment">//将a[i]放到正确位置上  </span></span><br><span class="line">            a[k + <span class="number">1</span>] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多直接插入排序的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/llzk_/article/details/51628574" target="_blank" rel="noopener">插入排序算法详解及实现</a></li><li><a href="https://blog.csdn.net/morewindows/article/details/6665714" target="_blank" rel="noopener">白话经典算法系列之二 直接插入排序的三种实现</a></li></ul></blockquote><h5 id="7.1.2"> 7.1.2 折半插入排序 </h5><blockquote><p>插入排序的基本操作是在一个有序表中进行查找和插入。利用“折半查找”的查找操作实现的插入排序，称为<strong>折半插入排序</strong><code>Binary Insertion Sort</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Elemtype A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        low=<span class="number">1</span>;</span><br><span class="line">        high=i<span class="number">-1</span>;<span class="comment">//设置折半查找的范围，从1到i-1,A[0]用来暂存元素</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid].key&gt;A[<span class="number">0</span>].key) high=mid<span class="number">-1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;<span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];<span class="comment">//统一向后移动元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多折半插入排序的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/m0_37316917/article/details/70990523" target="_blank" rel="noopener">数据结构折半插入排序</a> -&gt;<em>recommend</em>！</li></ul></blockquote><h5 id="7.1.3"> 7.1.3 希尔排序 </h5><blockquote><p><strong>希尔排序</strong><code>Shell&#39;s Sort</code>又称最小增量排序，它的基本思想是将整个待排序记录序列分割成若干个子序列分别进行<strong>插入排序</strong>，待整个序列的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> <span class="comment">// O(n*n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> gap = len;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        gap = gap / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=gap; i&lt;len; i+=gap) &#123;</span><br><span class="line">            k = i;</span><br><span class="line">            temp = <span class="built_in">array</span>[k];</span><br><span class="line">            <span class="keyword">for</span> (j=i-gap; (j&gt;=<span class="number">0</span>) &amp;&amp; (<span class="built_in">array</span>[j]&gt;temp); j-=gap) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j+gap] = <span class="built_in">array</span>[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">array</span>[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (gap &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多希尔排序的知识，请戳：</p><ul><li><a href="http://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></li><li><a href="https://blog.csdn.net/daiyudong2020/article/details/52445044" target="_blank" rel="noopener">希尔排序详解</a> -&gt;<em>recommend</em>！</li><li><a href="https://www.cnblogs.com/ronnydm/p/5905715.html" target="_blank" rel="noopener">排序五：希尔排序</a>  -&gt;<em>recommend</em>！</li></ul></blockquote><h4 id="7.2"> 7.2 交换排序 </h4><h5 id="7.2.1"> 7.2.1 冒泡排序 </h5><blockquote><p>冒泡排序算法的运作如下：（从后往前）</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </li></ol></blockquote><ul><li>时间复杂度</li></ul><p>冒泡排序最好的时间复杂度为 $O(n)$。<br>冒泡排序的最坏时间复杂度为 $O(n^2)$。<br>综上，因此冒泡排序总的平均时间复杂度为 $O(n^2)$。</p><ul><li>算法稳定性</li></ul><p><strong>冒泡排序</strong><code>Bubble Sort</code>就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;  T temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多冒泡排序的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/morewindows/article/details/6657829" target="_blank" rel="noopener">白话经典算法系列之一 冒泡排序的三种实现</a></li><li><a href="https://www.cnblogs.com/crystalmoore/p/5929814.html" target="_blank" rel="noopener">经典排序算法学习笔记一——冒泡排序</a></li></ul></blockquote><h5 id="7.2.2"> 7.2.2 快速排序 </h5><blockquote><p><strong>快速排序</strong><code>Quick Sort</code>是对<strong>冒泡排序</strong>的一种改进。它的基本思想是，通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，继续进行排序以达到整个序列有序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PartSort1</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><span class="comment">//左右指针法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> mid = GetMidIndex(a,left,right);    <span class="comment">//此处是对快排的优化，再后面会提到  </span></span><br><span class="line">    swap(a[mid],a[right]);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> key = right;<span class="comment">//利用key作为基准值的下标  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//左指针向右找第一个比key大的数  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[key])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++left;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//右指针向左扎找第一个比key的数  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[key])  </span><br><span class="line">        &#123;  </span><br><span class="line">            --right;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//交换左右指针所指的值  </span></span><br><span class="line">        <span class="keyword">if</span> (a[left] != a[right])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">std</span>::swap(a[left],a[right]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将key值放到正确位置上  </span></span><br><span class="line">    swap(a[left],a[key]);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> left;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度为：$O(nlogn)$</p><blockquote><p>更多快速排序的知识，请戳：</p><ul><li><a href="https://blog.csdn.net/code_ac/article/details/74158681" target="_blank" rel="noopener">快速排序基本思路（通俗易懂+例子）</a></li><li><a href="https://blog.csdn.net/payshent/article/details/60879120" target="_blank" rel="noopener">快速排序</a></li><li><a href="https://blog.csdn.net/code_ac/article/details/74158681" target="_blank" rel="noopener">快速排序基本思路（通俗易懂+例子）</a> -&gt;<em>recommend</em>！</li><li><a href="https://www.cnblogs.com/MOBIN/p/4681369.html" target="_blank" rel="noopener">图解快速排序</a> -&gt;<em>recommend</em>！</li></ul></blockquote><h4 id="7.3"> 7.3 选择排序 </h4><blockquote><p><strong>选择排序</strong><code>Selection Sort</code>：每一趟在$n-i+1(i=1,2,3,…,n-1)$个记录中选取关键字最小的记录作为有序序列的第$i$个记录。</p></blockquote><h5 id="7.3.1"> 7.3.1 简单选择排序 </h5><blockquote><p>一趟简单选择排序的操作是：通过$n-i$次关键字间的比较，从$n-i+1(i=1,2,3,…,n-1)$个记录中选取关键字最小的记录，并和第$i$个记录交换之。</p></blockquote><p>简单选择排序的时间复杂度为$O(n^2)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i,j,min,m;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=i;<span class="comment">//查找最小值</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[min]&gt;A[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;A[min],&amp;A[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>稳定性</li></ul><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。</p><blockquote><p>更多关于选择排序的知识，请戳：</p><ul><li><a href="http://baijiahao.baidu.com/s?id=1586561314836092820&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">经典排序算法之选择排序</a></li></ul></blockquote><h5 id="7.3.2"> 7.3.2 堆排序 </h5><blockquote><p><strong>堆排序</strong><code>Heap Sort</code>是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为$O(nlogn)$，它也是不稳定排序。首先简单了解下堆结构。</p></blockquote><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> param1,<span class="keyword">int</span> j, <span class="keyword">int</span> inNums[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> inNums[])</span></span>;</span><br><span class="line"><span class="comment">//大根堆进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> param1, <span class="keyword">int</span> j, <span class="keyword">int</span> inNums[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=inNums[param1];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=param1*<span class="number">2</span>+<span class="number">1</span>;k&lt;j;k=k*<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果右边值大于左边值，指向右边</span></span><br><span class="line">        <span class="keyword">if</span> (k+<span class="number">1</span>&lt;j &amp;&amp; inNums[k]&lt; inNums[k+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点,并以新的子节点作为父节点（不用进行交换）</span></span><br><span class="line">        <span class="keyword">if</span> (inNums[k]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            inNums[param1]=inNums[k];</span><br><span class="line">            param1=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//put the value in the final position</span></span><br><span class="line">    inNums[param1]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序主要算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> inNums[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=nums/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="comment">//put the value in the final position</span></span><br><span class="line">        adjustHeap(i,nums,inNums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=nums<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="comment">//堆顶元素和末尾元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> temp=inNums[<span class="number">0</span>];</span><br><span class="line">        inNums[<span class="number">0</span>]=inNums[j];</span><br><span class="line">        inNums[j]=temp;</span><br><span class="line"> </span><br><span class="line">        adjustHeap(<span class="number">0</span>,j,inNums);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多堆排序的知识，请戳：</p><ul><li><a href="https://www.jianshu.com/p/938789fde325" target="_blank" rel="noopener">浅谈堆排序</a></li><li><a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">堆排序详解</a> -&gt;<em>recommend</em>！</li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></li></ul></blockquote><h4 id="7.4"> 7.4 归并排序 </h4><blockquote><p><strong>归并排序</strong><code>Merging Sort</code>是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将有二个有序数列a[first...mid]和a[mid...last]合并。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = first, j = mid + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> m = mid,   n = last;  </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])  </span><br><span class="line">            temp[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            temp[k++] = a[j++];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)  </span><br><span class="line">        temp[k++] = a[i++];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)  </span><br><span class="line">        temp[k++] = a[j++];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)  </span><br><span class="line">        a[first + i] = temp[i];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (first &lt; last)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;  </span><br><span class="line">        mergesort(a, first, mid, temp);    <span class="comment">//左边有序  </span></span><br><span class="line">        mergesort(a, mid + <span class="number">1</span>, last, temp); <span class="comment">//右边有序  </span></span><br><span class="line">        mergearray(a, first, mid, last, temp); <span class="comment">//再将二个有序数列合并  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>, p);  </span><br><span class="line">    <span class="keyword">delete</span>[] p;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="https://blog.csdn.net/morewindows/article/details/6678165/" target="_blank" rel="noopener">白话经典算法系列之五 归并排序的实现</a></li></ul></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在数据结构和算法的路上，越走越远！~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;复习一下课没好好上过的数据结构，唉！要期末考试噜！数据结构和算法要是想成为&lt;code&gt;Master&lt;/code&gt;，好难欸！！~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：如何高效率使用这篇总结？&lt;br&gt;A：查看写的所有数据结构的定义，然后戳所有带&lt;code&gt;-&amp;gt; recommend！&lt;/code&gt;这个标识的链接，嗯！速度就是这样~认真的话，建议复写所有数据结构的实现代码啦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#1&quot;&gt;&lt;strong&gt;线性表&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 1.1 &lt;a href=&quot;#1.1&quot;&gt;顺序表示和实现&lt;/a&gt;&lt;br&gt; 1.2 &lt;a href=&quot;#1.2&quot;&gt;链式表示和实现&lt;/a&gt;&lt;br&gt; 1.2.1 &lt;a href=&quot;#1.2.1&quot;&gt;&lt;code&gt;线性链表&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 1.2.2 &lt;a href=&quot;#1.2.2&quot;&gt;&lt;code&gt;循环链表&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 1.2.3 &lt;a href=&quot;#1.2.3&quot;&gt;&lt;code&gt;双向链表&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#2&quot;&gt;&lt;strong&gt;栈和队列&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 2.1 &lt;a href=&quot;#2.1&quot;&gt;栈&lt;/a&gt;&lt;br&gt; 2.2 &lt;a href=&quot;#2.2&quot;&gt;队列&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#3&quot;&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 3.1 &lt;a href=&quot;#3.1&quot;&gt;数组的顺序表示和实现&lt;/a&gt;&lt;br&gt; 3.2 &lt;a href=&quot;#3.2&quot;&gt;矩阵的压缩存储&lt;/a&gt;&lt;br&gt; 3.2.1 &lt;a href=&quot;#3.2.1&quot;&gt;&lt;code&gt;稀疏矩阵&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#4&quot;&gt;&lt;strong&gt;树&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 4.1 &lt;a href=&quot;#4.1&quot;&gt;二叉树&lt;/a&gt;&lt;br&gt; 4.2 &lt;a href=&quot;#4.2&quot;&gt;遍历二叉树&lt;/a&gt;&lt;br&gt; 4.2.1 &lt;a href=&quot;#4.2.1&quot;&gt;&lt;code&gt;三大遍历的递归实现&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 4.2.2 &lt;a href=&quot;#4.2.2&quot;&gt;&lt;code&gt;三大遍历的非递归实现&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 4.2.3 &lt;a href=&quot;#4.2.3&quot;&gt;&lt;code&gt;层次遍历&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 4.3 &lt;a href=&quot;#4.3&quot;&gt;树和森林&lt;/a&gt;&lt;br&gt; 4.3.1 &lt;a href=&quot;#4.3.1&quot;&gt;&lt;code&gt;数和森林的存储结构&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 4.3.2 &lt;a href=&quot;#4.3.2&quot;&gt;&lt;code&gt;数和森林的遍历&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 4.4 &lt;a href=&quot;4.4&quot;&gt;赫夫曼树&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#5&quot;&gt;&lt;strong&gt;图&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 5.1 &lt;a href=&quot;#5.1&quot;&gt;图的定义&lt;/a&gt;&lt;br&gt; 5.2 &lt;a href=&quot;#5.2&quot;&gt;图的存储结构&lt;/a&gt;&lt;br&gt; 5.2.1 &lt;a href=&quot;#5.2.1&quot;&gt;&lt;code&gt;邻接表&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 5.2.2 &lt;a href=&quot;#5.2.2&quot;&gt;&lt;code&gt;十字链表&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 5.3 &lt;a href=&quot;#5.3&quot;&gt;图的遍历&lt;/a&gt;&lt;br&gt; 5.3.1 &lt;a href=&quot;#5.3.1&quot;&gt;&lt;code&gt;深度优先搜索&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 5.3.2 &lt;a href=&quot;#5.3.2&quot;&gt;&lt;code&gt;广度优先搜索&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 5.4 &lt;a href=&quot;#5.4&quot;&gt;图的连通性&lt;/a&gt;&lt;br&gt; 5.4.1 &lt;a href=&quot;#5.4.1&quot;&gt;&lt;code&gt;最小生成树&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 5.5 &lt;a href=&quot;#5.5&quot;&gt;拓扑排序&lt;/a&gt;&lt;br&gt; 5.6 &lt;a href=&quot;#5.6&quot;&gt;最短路径&lt;/a&gt;&lt;br&gt; 5.6.1 &lt;a href=&quot;#5.6.1&quot;&gt;&lt;code&gt;Dijkstra算法&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#6&quot;&gt;&lt;strong&gt;查找&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 6.1 &lt;a href=&quot;#6.1&quot;&gt;静态查找&lt;/a&gt;&lt;br&gt; 6.1.1 &lt;a href=&quot;#6.1.1&quot;&gt;&lt;code&gt;顺序查找&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 6.1.2 &lt;a href=&quot;#6.1.2&quot;&gt;&lt;code&gt;二分查找&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 6.2 &lt;a href=&quot;#6.2&quot;&gt;动态查找&lt;/a&gt;&lt;br&gt; 6.2.1 &lt;a href=&quot;#6.2.1&quot;&gt;&lt;code&gt;二叉排序树&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 6.3 &lt;a href=&quot;#6.3&quot;&gt;哈希表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#7&quot;&gt;&lt;strong&gt;内部排序&lt;/strong&gt;&lt;/a&gt;&lt;br&gt; 7.1 &lt;a href=&quot;#7.1&quot;&gt;插入排序&lt;/a&gt;&lt;br&gt; 7.1.1 &lt;a href=&quot;#7.1.1&quot;&gt;&lt;code&gt;直接插入排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.1.2 &lt;a href=&quot;#7.1.2&quot;&gt;&lt;code&gt;折半插入排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.1.3 &lt;a href=&quot;#7.1.3&quot;&gt;&lt;code&gt;希尔排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.2 &lt;a href=&quot;#7.2&quot;&gt;交换排序&lt;/a&gt;&lt;br&gt; 7.2.1 &lt;a href=&quot;#7.2.1&quot;&gt;&lt;code&gt;冒泡排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.2.2 &lt;a href=&quot;#7.2.2&quot;&gt;&lt;code&gt;快速排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.3 &lt;a href=&quot;#7.3&quot;&gt;选择排序&lt;/a&gt;&lt;br&gt; 7.3.1 &lt;a href=&quot;#7.3.1&quot;&gt;&lt;code&gt;简单选择排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.3.2 &lt;a href=&quot;#7.3.2&quot;&gt;&lt;code&gt;堆排序&lt;/code&gt;&lt;/a&gt;&lt;br&gt; 7.4 &lt;a href=&quot;#7.4&quot;&gt;归并排序&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1&quot;&gt; 1. 线性表 &lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;线性表&lt;code&gt;Linear_list&lt;/code&gt;是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1.1&quot;&gt; 1.1 顺序表示和实现 &lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初识wsl（Windows Subsystem for Linux），微软这次真的给了我惊喜！</title>
    <link href="https://blog.fuujiro.com/2018/04/27/%E5%88%9D%E8%AF%86wsl%EF%BC%88Windows-Subsystem-for-Linux%EF%BC%89%E7%9A%84Surprise%EF%BC%8C%E5%BE%AE%E8%BD%AF%E8%BF%99%E6%AC%A1%E7%9C%9F%E7%9A%84%E7%BB%99%E4%BA%86%E6%88%91%E6%83%8A%E5%96%9C%EF%BC%81/"/>
    <id>https://blog.fuujiro.com/2018/04/27/初识wsl（Windows-Subsystem-for-Linux）的Surprise，微软这次真的给了我惊喜！/</id>
    <published>2018-04-27T13:43:20.000Z</published>
    <updated>2018-06-12T11:00:36.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Surprise！"><a href="#Surprise！" class="headerlink" title="Surprise！"></a>Surprise！</h3><p>这次，微软给了我们一个<code>surprise</code>！当然，我得到的消息是不是太晚！！因为，我看知乎他们似乎在两年前就开始尝鲜<code>WSL</code>了，但那时的<code>wsl</code>似乎还是不太稳定的，而到了2018年，在体验了<code>WSL</code>后，我对她非常满意！嗯，就像微软所说，<strong>Windows love Linux</strong>，而<code>wsl</code>的的确确地让我体验到了<code>Linux</code>的feel！不得不感慨，巨硬大法好👌！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Surprise！&quot;&gt;&lt;a href=&quot;#Surprise！&quot; class=&quot;headerlink&quot; title=&quot;Surprise！&quot;&gt;&lt;/a&gt;Surprise！&lt;/h3&gt;&lt;p&gt;这次，微软给了我们一个&lt;code&gt;surprise&lt;/code&gt;！当然，我得到的消息是不是太晚！！因为，我看知乎他们似乎在两年前就开始尝鲜&lt;code&gt;WSL&lt;/code&gt;了，但那时的&lt;code&gt;wsl&lt;/code&gt;似乎还是不太稳定的，而到了2018年，在体验了&lt;code&gt;WSL&lt;/code&gt;后，我对她非常满意！嗯，就像微软所说，&lt;strong&gt;Windows love Linux&lt;/strong&gt;，而&lt;code&gt;wsl&lt;/code&gt;的的确确地让我体验到了&lt;code&gt;Linux&lt;/code&gt;的feel！不得不感慨，巨硬大法好👌！&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>全站https化&amp;全方位SEO优化！焕然一新喔～</title>
    <link href="https://blog.fuujiro.com/2018/04/13/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BC%98%E5%8C%96%EF%BC%81%E7%84%95%E7%84%B6%E4%B8%80%E6%96%B0%E5%96%94%EF%BD%9E/"/>
    <id>https://blog.fuujiro.com/2018/04/13/对网站进行全方位优化！焕然一新喔～/</id>
    <published>2018-04-13T15:46:36.000Z</published>
    <updated>2018-06-12T11:00:36.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近学习一些信息安全和计算机网络方面的知识，知道了<code>http</code>和<code>https</code>的差距，现在全网各大网站和平台都在进行全站<code>https</code>化，所以我准备把我的<a href="https://blog.fuujiro.com/">fuujiro’s land</a>也实现一波全站https化。除了这个之外，我也打算对我的blog进行<code>SEO</code>优化。<code>SEO</code>优化这是门大学问，不论是我这样的小小blog，还是大厂的页面，都会试图让自家的产品和网站出现在搜索引擎最靠前的位置，<code>SEO</code>优化大概就是在干这样一件事～</p><h3 id="1-实现全站https化"><a href="#1-实现全站https化" class="headerlink" title="1. 实现全站https化"></a>1. 实现全站<code>https</code>化</h3><h4 id="1-1-为什么要进行https化"><a href="#1-1-为什么要进行https化" class="headerlink" title="1.1 为什么要进行https化"></a>1.1 为什么要进行<code>https</code>化</h4><p>先说说<code>http</code>和<code>https</code>的区别：</p><blockquote><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p></blockquote><p>其中HTTPS和HTTP的区别主要如下：</p><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>所以～尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ul><p>So，大家赶紧一起撸起袖子把自己的网站 or 博客实现全站<code>https</code>化吧！！</p><h4 id="1-2-所需要的工具和基础："><a href="#1-2-所需要的工具和基础：" class="headerlink" title="1.2 所需要的工具和基础："></a>1.2 所需要的工具和基础：</h4><ul><li>仓库：<code>Github</code></li><li>Hexo 博客主题：<code>Apollo</code></li><li>评论插件：<code>Disqus</code></li><li>SSL证书 &amp; 服务器：<code>CloudFlare</code></li><li>个人域名(腾讯云)一个</li></ul><blockquote><p>注意：如果你的hexo blog并没有自己额外购买的独立域名如<code>fuujiro.com</code>，在使用<code>GitHub Pages</code>自带的<code>yourname.github.io</code>，那么其实你是不需要进行<code>手动https</code>，因为<code>*GitHub Pages</code>自带<code>https</code>优化了。买独立域名的优势是可以让搜索引擎检索到，比如百度这种公司是不检索<code>github.io</code>的…</p></blockquote><h4 id="1-3-步骤"><a href="#1-3-步骤" class="headerlink" title="1.3 步骤"></a>1.3 步骤</h4><p>现在默认已经将博客搭好了，也链接上了自己的独立域名，如果没有，请参考我的另一篇博客：<a href="https://blog.fuujiro.com/2018/02/14/%E4%BD%BF%E7%94%A8Hexo%E6%A1%86%E6%9E%B6-Apollo%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">使用Hexo框架+Apollo主题搭建博客</a></p><h5 id="1-3-1-注册一个CloudFlare账户"><a href="#1-3-1-注册一个CloudFlare账户" class="headerlink" title="1.3.1 注册一个CloudFlare账户"></a>1.3.1 注册一个<code>CloudFlare</code>账户</h5><ol><li><p>首先进入<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudflare</a>，注册好你的账户，然后绑好你的个人域名。教程：<a href="http://www.wugongqi.cn/2700.html" target="_blank" rel="noopener">如何注册使用cloudfare？</a></p></li><li><p>进行完第一步的基本操作后，你会得到<code>cloudfare</code>赏给你的两个服务器DNS地址：</p></li></ol><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/对网站进行全方位SEO优化/DeepinScreenshot_select-area_20180413102513.png" alt="DNS"></p><p>把这两个地址copy好，打开你购买你的域名的服务商，比如我用的是腾讯云。按下面步骤操作，其他网站也大同小异，就是修改一下域名的DNS服务器。</p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/对网站进行全方位SEO优化/DeepinScreenshot_select-area_20180427205201.png" alt="tencentYUN"></p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/对网站进行全方位SEO优化/a_20180413103553.png" alt="tencentYUN"></p><p>最后，使用<a href="https://www.whois.net/" target="_blank" rel="noopener">whois工具</a>查看是否已经更改服务器成功。</p><blockquote><p>更改之前(我的域名是腾讯云购买的，所以云解析的服务器也是腾讯云)。</p></blockquote><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8DSEO%E4%BC%98%E5%8C%96/DeepinScreenshot_select-area_20180413102311.png" alt="aliyun"></p><blockquote><p>更改以后，服务器DNS解析转移到cloudfare服务器。</p></blockquote><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8DSEO%E4%BC%98%E5%8C%96/DeepinScreenshot_select-area_20180427203932.png" alt="cloudfare"></p><p>这意味着你去成功了，这时候进入<code>cloudfare</code>主页，你的域名的状态就是<code>Active</code>了(可能<code>cloudfare</code>因为服务器缓存的原因，会晚几小时，不过如果whois查看已修改了，基本没有问题)，就像下面这样。</p><hr><p><strong>注意</strong>：以下所有操作的前提建立在，域名的状态是<code>Active</code>：</p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/对网站进行全方位SEO优化/DeepinScreenshot_select-area_20180413102540.png" alt="Active"></p><p>如果域名状态还未变绿，说明你还不够成熟，请您继续上面两步的操作。因为你继续下去也不会有结果，就像你死缠难打也不会有女朋友一样。</p><hr><ol start="3"><li>接下来，就是cloudfare的优化操作了。</li></ol><ul><li>实现全站<code>https</code>化</li></ul><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8DSEO%E4%BC%98%E5%8C%96/DeepinScreenshot_select-area_20180427211022.png" alt="first"></p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/对网站进行全方位SEO优化/DeepinScreenshot_select-area_20180427211140.png" alt="first"></p><ul><li>实现网站加速（关于<code>Page Rules</code>可以搜索引擎了解）</li></ul><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8DSEO%E4%BC%98%E5%8C%96/DeepinScreenshot_select-area_20180427210836.png" alt="second"></p><p>至此，你重新刷新的网站or博客页面，域名地址左侧出现绿色小锁标识，恭喜你，你已经实现<code>https</code>化。至于全站<code>https</code>化，请保持你网站上所有引用的图片链接，也必须是https网站的，否则无法实现全站<code>https</code>化，实现<code>https</code>后的<a href="https://blog.fuujiro.com/">fuujiro’s island</a>：</p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/%E5%AF%B9%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%B9%E4%BD%8DSEO%E4%BC%98%E5%8C%96/DeepinScreenshot_google-chrome_20180427212529.png" alt="fuujiro&#39;s island"></p><h3 id="2-全方位SEO优化"><a href="#2-全方位SEO优化" class="headerlink" title="2. 全方位SEO优化"></a>2. 全方位<code>SEO</code>优化</h3><hr><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近学习一些信息安全和计算机网络方面的知识，知道了&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;https&lt;/code&gt;的差距，现在全网各大网站和平台都在进行全站&lt;code&gt;https&lt;/code&gt;化，所以我准备把我的&lt;a href=&quot;https://blog.fuujiro.com/&quot;&gt;fuujiro’s land&lt;/a&gt;也实现一波全站https化。除了这个之外，我也打算对我的blog进行&lt;code&gt;SEO&lt;/code&gt;优化。&lt;code&gt;SEO&lt;/code&gt;优化这是门大学问，不论是我这样的小小blog，还是大厂的页面，都会试图让自家的产品和网站出现在搜索引擎最靠前的位置，&lt;code&gt;SEO&lt;/code&gt;优化大概就是在干这样一件事～&lt;/p&gt;
&lt;h3 id=&quot;1-实现全站https化&quot;&gt;&lt;a href=&quot;#1-实现全站https化&quot; class=&quot;headerlink&quot; title=&quot;1. 实现全站https化&quot;&gt;&lt;/a&gt;1. 实现全站&lt;code&gt;https&lt;/code&gt;化&lt;/h3&gt;&lt;h4 id=&quot;1-1-为什么要进行https化&quot;&gt;&lt;a href=&quot;#1-1-为什么要进行https化&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要进行https化&quot;&gt;&lt;/a&gt;1.1 为什么要进行&lt;code&gt;https&lt;/code&gt;化&lt;/h4&gt;&lt;p&gt;先说说&lt;code&gt;http&lt;/code&gt;和&lt;code&gt;https&lt;/code&gt;的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中HTTPS和HTTP的区别主要如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。&lt;/li&gt;
&lt;li&gt;http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。&lt;/li&gt;
&lt;li&gt;http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。&lt;/li&gt;
&lt;li&gt;http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以～尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；&lt;/li&gt;
&lt;li&gt;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。&lt;/li&gt;
&lt;li&gt;HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/li&gt;
&lt;li&gt;谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vim-蓝色星球迄今为止最强大的编辑器（持续更新</title>
    <link href="https://blog.fuujiro.com/2018/03/10/vim-%E8%93%9D%E8%89%B2%E6%98%9F%E7%90%83%E8%BF%84%E4%BB%8A%E4%B8%BA%E6%AD%A2%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://blog.fuujiro.com/2018/03/10/vim-蓝色星球迄今为止最强大的编辑器（持续更新/</id>
    <published>2018-03-10T14:06:11.000Z</published>
    <updated>2018-06-12T11:00:36.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-故事-“编辑器之神”"><a href="#1-故事-“编辑器之神”" class="headerlink" title="1. 故事 - “编辑器之神”"></a>1. 故事 - “编辑器之神”</h3><p>为什么<code>Vim</code>被称为编辑器之神？话说啊，远古时候，有两大神仙，地上很多猿类大多分成两派，一部分仰慕<code>Vim</code>大神，另一部分崇拜<code>Emacs</code>大仙，这两派互相挖苦比较，只相信自己的信仰之神是最强大的！<del>我呢，暂时站<code>Vim</code>神的，不排除以后叛变啦！</del></p><p>好了，正经说话吧！高校里教学c语言时，应该是用的<code>VC++6.0</code> or <code>VS2010</code>，这两个是编辑器嘛？当然，不是的！他们都是集成开发环境（<code>IDE</code>，<code>Integrated Development Environment</code>）,而<code>Vim</code>才是编辑器，与<code>vim</code>一起称作编辑器还有啥子呢？比如，<code>Emacs</code>（Vim在这个世界上的最强大对手）,<code>VS code</code>（Microsoft推出的开源编辑器，是我最近使用的最频繁的编辑器，可以说面对学习曲线陡峭的Vim来说，<code>VS code</code>是最容易上手的编辑器，我现在在写的这篇blog就是用<code>VS code</code>写的，插件十分丰富，除了由于GUI界面的存在，可能在内存上稍高于<code>Vim</code>，但比起鬼畜的<code>Atom</code>来说，那是好到不知道哪里去了的存在）,<code>Atom</code>（Google推出的开源编辑器，同样因为开源的原因，插件十分丰富）,<code>Sublime Text</code>（前端engineer一定经历过的编辑器，插件丰富，性能极优）等等……</p><p>好了，你现在肯定会问我，为啥我这次blog只介绍Vim呢？因为，Vim难学啊！这里有一张网上嘲讽几大编辑器的学习曲线～<br><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/主流編輯器學習曲線圖.jpg" alt="vim-line"></p><h3 id="2-学习Vim能给你带来什么？"><a href="#2-学习Vim能给你带来什么？" class="headerlink" title="2. 学习Vim能给你带来什么？"></a>2. 学习Vim能给你带来什么？</h3><p>从图上我们能看出，vim（vi）的学习曲线入门是十分陡峭的，Emacs的略显鬼畜2333～！那，学习Vim对于我来说，到底有什么什么好处呢？我在刚刚学习Vim时，也是有抱着这个疑惑的，后来总是强迫自己去学+在网上了解Vim，我觉得学习对你可能会有这些好处：</p><ul><li><p>熟悉命令行工具：Vim是在终端（Terminal）上运行的编辑器，学习Vim无疑你会在命令行下进行频繁操作，而命令行工具对于程序员来说，是十分重要的！也许大部分同学的开发环境大部分还是Windows，使用命令行工具的机会很少！但是以后科研or工作，开发平台就不一定是Windows了，也不一定会有带图形界面的开发工具给你使用。比如：</p><ul><li>你科研跑TensorFlow，进行深度学习方面的科研，大概率会需要在linux上跑；做机器学习离不开Linux～我最近在做计算机视觉（Computer Vision）的研究，小方向现在做的是对机械臂进行视觉定位，然而这个机械臂的ROS操作工具，就必须在Linux下进行~～macOS&amp;Windows都没提供~~</li><li>你是EE爱好者（robot开发方向的爱好者），而ROS (Robot Operating System, 机器人操作系统) 恰恰只提供给你Linux的开发工具（且只保证Ubuntu（Linux的一个发行版）能够完美兼容），你作为机器人方向开发者，无法避免命令行工具的使用</li><li>除了科研界，工程界对于命令行工具的使用不要太多！各大互联网的大厂的每一个开发岗offer，无论你是c/c++/java/python/c#/前端/运维等，哪个岗位要求都会有这么一句“熟悉使用命令行操作工具”or“熟悉shell脚本语言编程”，可以说，使用命令行工具是一位合格的计算机专业大学生应该具有的。</li></ul></li><li><p>Vim具有其他编辑器不具有的与生俱来的特殊功能，比如轻松运用SSH（SSH指：. Secure Shell（缩写：SSH），即“安全壳协议”，一项计算机上的安全协议）；Vim内存占用很低，对于开发配置要求极低，比起具有图形界面的VS code，Atom，Sublime来说，可以说能开机的电脑都能顺溜地跑Vim～！</p></li><li><p>最后一个：Vim能帮助乌干达的贫苦儿童，这是个梗2333～！不过，认真讲哦～你用Vim写代码，是在帮助世界上的其他小孩子呢！还有什么理由，不好好写代码233～！<br><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/4170551-f560a9916f58202d.jpg" alt="Uganda"></p></li></ul><p>相信前面的大串理由，你一定拒绝不了Vim的诱惑，不如和我一起来学习Vim工具吧～啦啦啦～！</p><h3 id="3-Vim介绍以及如何入门"><a href="#3-Vim介绍以及如何入门" class="headerlink" title="3. Vim介绍以及如何入门"></a>3. Vim介绍以及如何入门</h3><h4 id="3-1-Vim和Vi的关系"><a href="#3-1-Vim和Vi的关系" class="headerlink" title="3.1 Vim和Vi的关系"></a>3.1 Vim和Vi的关系</h4><p>通过搜索引擎了解一下，就简单黏上来了！自己写的没有这么全面～<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vim和Vi都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。</span><br><span class="line">vim的这些优势主要体现在以下几个方面：</span><br><span class="line">1、多级撤消</span><br><span class="line">我们知道在vi里，按`u`只能撤消上次命令，而在vim里可以无限制的撤消。</span><br><span class="line">2、易用性</span><br><span class="line">vi只能运行于unix中，而vim不仅可以运行于unix,windows ,mac等多操作平台。</span><br><span class="line">3、语法加亮</span><br><span class="line">vim可以用不同的颜色来加亮你的代码。</span><br><span class="line">4、可视化操作</span><br><span class="line">就是说vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows。</span><br><span class="line">5、对vi的完全兼容</span><br><span class="line">某些情况下，你可以把vim当成vi来使用。</span><br></pre></td></tr></table></figure></p><p>所以，我们通常就把Vim包括了Vi啦～！</p><h4 id="3-2-Vim安装"><a href="#3-2-Vim安装" class="headerlink" title="3.2 Vim安装"></a>3.2 Vim安装</h4><p>按道理来说，现如今的操作系统（除Windows）都已经自带好了Vim。为了避免古老版本只安装Vi的gg情况，我们可以先敲<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -version</span><br></pre></td></tr></table></figure></p><p>来确定计算机是否已经安装好了Vim，一般出现的结果就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuujiro-Mac:~ fuujiro$ vim -version</span><br><span class="line">VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Jul 26 2017 19:10:24)</span><br></pre></td></tr></table></figure></p><p>如上结果的话，你的计算机就已经安装好了Vim，版本是8.0。<br>当然如果提示<code>command not found</code>，那也不慌，我们装上就好：</p><ul><li><p>Linux用户：<br>  因为Linux存在两大派系，Debian和Redhat，对于不同派系，安装命令也不相同。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu系统（基于Debian）：</span><br><span class="line">普通用户下输入命令：sudo apt-get install vim-gtk</span><br><span class="line">centos系统（基于Redhat）：</span><br><span class="line">普通用户下输入命令：yum -y install vim*</span><br></pre></td></tr></table></figure></li><li><p>macOS用户：<br>  macOS是自带Vim的，但由于随系统版本的原因，可能版本落后，那就讲一下Vim的升级吧～！<br>  我是推荐用Homebrew（Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程）来升级的。</p><ol><li><p>安装Homebrew</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装or升级Vim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装Vim</span><br><span class="line">$ brew install vim</span><br><span class="line">升级Vim</span><br><span class="line">$ brew update vim</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Windows用户<br>  Windows因为不是*nix类系统，所以不会自带Vim，不过已经有大牛开发出了vim在Windows上的编辑器-gvim</p><ul><li><a href="http://blog.csdn.net/myloveqingmu/article/details/52518563" target="_blank" rel="noopener">gvim+w7+vundle安装教程</a><br>上面这个文章清晰的解释了每一步，跟着做就好。</li></ul></li></ul><h4 id="3-3-Vim入门"><a href="#3-3-Vim入门" class="headerlink" title="3.3 Vim入门"></a>3.3 Vim入门</h4><h5 id="3-3-1-vim的基础模式"><a href="#3-3-1-vim的基础模式" class="headerlink" title="3.3.1 vim的基础模式"></a>3.3.1 vim的基础模式</h5><p>在使用vim时，主要你会在两个模式下操作：</p><ul><li>正常（normal）模式：任何其它模式中都可以通过键盘上的 Esc 键回到正常模式。在这个模式下可以进行命令（commmand）模式操作（按:进入）。例如，wq是保存并退出，q!是强制退出不保存。</li><li>输入（insert）模式，输入文本时使用；在正常模式下键入“i”（insert）或“a”（append）即可进入插入模式。这时候一般进行文本编辑工作，例如写代码。</li></ul><p>当然除了这两种模式，还有可视（visual）模式：用于选定文本块；可以在正常模式下输入“v”（小写）来按字符选定，输入“V”（大写）来按行选定，或输入“Ctrl-V”来按方块选定。主要的话，还是上面那2种模式用的比较多。</p><h5 id="3-3-2-vim的基本操作"><a href="#3-3-2-vim的基本操作" class="headerlink" title="3.3.2 vim的基本操作"></a>3.3.2 vim的基本操作</h5><p>你如果是第一次接触命令行，可以在打开终端（open terminal），敲下<code>vimtutor</code>然后按下回车，就可以看到（如下图）</p><p><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/DeepinScreenshot_select-area_20180331125208.png" alt="vimtutor"></p><p>这是vim的学习文档，文档语言取决于你的系统语言，所以不会英语的小伙伴也不必害怕学习vim，毕竟中文文档也是挺丰富的，不过我还是推荐学习好英语的。</p><p>好，现在默认大家都已经跟着<code>vimtutor</code>过了一遍了，那再复现一下文档里的一些主要的操作。</p><p>注意：</p><ul><li><p>首先是控制光标移动的方向键，依然还是可以用上下左右键的，不过vim发明者的本意是提高使用者的打字效率，所以推荐<code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>这4个键分别，这样你的双手就不用离开主键盘区了，完完全全的效率工具。当然，刚刚开始使用时，你会觉得有点变扭，不过熟悉后你肯定会赞成我这句话的。</p></li><li><p>在插入模式下按<code>:</code>键就可以进入命令模式；在命令模式下按<code>i</code>就可以进入插入模式。在插入模式下，输入<code>wq</code>可以保存并退出文件，按<code>q!</code>是强制退出不保存。如果有需要保存的路径，那么就<code>w</code>+<code>空格</code>+<code>保存文件的路径</code>。</p></li></ul><p>总结的详细操作：</p><h4 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h4><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h4 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h4><p>在命令行窗口中输入以下命令即可</p><p>vim 直接启动vim</p><p>vim filename 打开vim并创建名为filename的文件</p><h4 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h4><p>打开单个文件</p><p>vim file</p><p>同时打开多个文件</p><p>vim file1 file2 file3 …</p><p>在vim窗口中打开一个新文件</p><p>:open file</p><p>在新窗口中打开文件</p><p>:split file</p><p>切换到下一个文件</p><p>:bn</p><p>切换到上一个文件</p><p>:bp</p><p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p><p>:args</p><p>打开远程文件，比如ftp或者share folder</p><p>:e <a href="ftp://192.168.10.76/abc.txt" target="_blank" rel="noopener">ftp://192.168.10.76/abc.txt</a></p><p>:e \qadrive\test\1.txt</p><h4 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h4><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p><h4 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h4><p>% 括号匹配</p><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><p>i 在当前位置生前插入</p><p>I 在当前行首插入</p><p>a 在当前位置后插入</p><p>A 在当前行尾插入</p><p>o 在当前行之后插入一行</p><p>O 在当前行之前插入一行</p><h4 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h4><p>/text　　查找text，按n健查找下一个，按N健查找前一个。</p><p>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p><p>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</p><p>:set ignorecase　　忽略大小写的查找</p><p>:set noignorecase　　不忽略大小写的查找</p><p>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</p><p>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</p><p>:set nohlsearch　　关闭高亮搜索显示</p><p>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</p><p>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</p><p>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h4 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h4><p>ra 将当前字符替换为a，当期字符即光标所在字符。</p><p>s/old/new/ 用old替换new，替换当前行的第一个匹配</p><p>s/old/new/g 用old替换new，替换当前行的所有匹配</p><p>%s/old/new/ 用old替换new，替换所有行的第一个匹配</p><p>%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><p>:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。</p><p>ddp 交换光标所在行和其下紧邻的一行。</p><h4 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h4><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<esc>，这里的Esc是必须的，否则命令不生效。</esc></p><p>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</p><p>b 向后移动一个单词 2b 向后移动2个单词</p><p>e，同w，只不过是光标停在单词尾部</p><p>ge，同b，光标停在单词尾部。</p><p>^ 移动到本行第一个非空白字符上。</p><p>0（数字0）移动到本行第一个字符上，</p><p><home> 移动到本行第一个字符。同0健。</home></p><p>$ 移动到行尾 3$ 移动到下面3行的行尾</p><p>gg 移动到文件头。 = [[</p><p>G（shift + g） 移动到文件尾。 = ]]</p><p>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</p><p>F 同f，反向查找。</p><p>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</p><p>Ctrl + e 向下滚动一行</p><p>Ctrl + y 向上滚动一行</p><p>Ctrl + d 向下滚动半屏</p><p>Ctrl + u 向上滚动半屏</p><p>Ctrl + f 向下滚动一屏</p><p>Ctrl + b 向上滚动一屏</p><h4 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h4><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><p>x 删除当前字符</p><p>3x 删除当前光标开始向后三个字符</p><p>X 删除当前字符的前一个字符。X=dh</p><p>dl 删除当前字符， dl=x</p><p>dh 删除前一个字符</p><p>dd 删除当前行</p><p>dj 删除上一行</p><p>dk 删除下一行</p><p>10d 删除当前行开始的10行。</p><p>D 删除当前字符至行尾。D=d$</p><p>d$ 删除当前字符之后的所有字符（本行）</p><p>kdgg 删除当前行之前所有行（不包括当前行）</p><p>jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）</p><p>:1,10d 删除1-10行</p><p>:11,$d 删除11行及以后所有的行</p><p>:1,$d 删除所有行</p><p>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p><h4 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h4><p>yy 拷贝当前行</p><p>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</p><p>p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</p><p>shift+p 在当前行前粘贴</p><p>:1,10 co 20 将1-10行插入到第20行之后。</p><p>:1,$ co $ 将整个文件复制一份并添加到文件尾部。</p><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p><p>ddp交换当前行和其下一行</p><p>xp交换当前字符和其后一个字符</p><h4 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h4><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</p><p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</p><p>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</p><p>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h4 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h4><p>:wq 保存并退出</p><p>ZZ 保存并退出</p><p>:q! 强制退出并忽略所有更改</p><p>:e! 放弃所有修改，并打开原来文件。</p><h4 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h4><p>:split或new 打开一个新窗口，光标停在顶层的窗口上</p><p>:split file或:new file 用新窗口打开文件</p><p>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</p><p>Ctrl+ww 移动到下一个窗口</p><p>Ctrl+wj 移动到下方的窗口</p><p>Ctrl+wk 移动到上方的窗口</p><p>关闭窗口</p><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</p><p>:q 如果是最后一个被关闭的窗口，那么将退出vim。</p><p>ZZ 保存并退出。</p><p>关闭所有窗口，只保留当前窗口</p><p>:only</p><p>录制宏</p><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h4 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h4><p>:!command</p><p>:!ls 列出当前目录下文件</p><p>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</p><p>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</p><p>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p><h4 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h4><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p><p>3,5 s/^/#/g 注释第3-5行</p><p>3,5 s/^#//g 解除3-5行的注释</p><p>1,$ s/^/#/g 注释整个文档。</p><p>:%s/^/#/g 注释整个文档，此法更快。</p><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help <esc> 特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<esc> 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</esc></esc></p><h4 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h4><p>. 重复前一次命令</p><p>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</p><p>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</p><p>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p><p>Vim教程</p><ul><li>在Unix系统上 $ vimtutor</li><li>在Windows系统上 :help tutor</li></ul><p>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p><p>最后贴2张Vim的命令大全图，可以留着当壁纸，时不时看几眼，没准就都记住了呢～<br><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/20160712110935064.png" alt="Vim命令图1"><br><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/343184-20170103184312878-397465891.png" alt="Vim命令图2"><br><img src="https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/175824-20161123224659425-328736487.png" alt="Vim命令图3"></p><h3 id="4-Vim的终极配置"><a href="#4-Vim的终极配置" class="headerlink" title="4. Vim的终极配置"></a>4. Vim的终极配置</h3><p>vim是一个开放性很强的编辑器，个性化定制很丰富，你可以创建一个完全自我定制的<code>vimrc</code>，然后自己选择一些插件安装。不过，我推荐一个高度定制好的vim配置，正在使用的，它不一定是完美的，但的确是一款好用的。那就是<code>spf13-vim</code>，它的官方地址是：</p><ul><li><a href="http://vim.spf13.com/" target="_blank" rel="noopener">spf13-vim官网</a></li><li><a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">spf13-vim的GitHUb仓库地址</a></li></ul><p>这两个地址，都有详细的安装介绍，我就不多说了，打字受累，大家可以参考介绍，搭建你自己的vim终极配置！</p><h3 id="5-Vim使用时遇到过的问题及处理方法（持续更新"><a href="#5-Vim使用时遇到过的问题及处理方法（持续更新" class="headerlink" title="5. Vim使用时遇到过的问题及处理方法（持续更新"></a>5. Vim使用时遇到过的问题及处理方法（持续更新</h3><p>祝大家使用Vim更加爽快～！在编程的道路上越走越远～！</p><p>致谢：</p><ol><li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">令狐葱@前端笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">吴润的知乎专栏：cs专业那些事</a></li><li><a href="https://www.cnblogs.com/yangjig/p/6014198.html" target="_blank" rel="noopener">vim常用命令总结 （转)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-故事-“编辑器之神”&quot;&gt;&lt;a href=&quot;#1-故事-“编辑器之神”&quot; class=&quot;headerlink&quot; title=&quot;1. 故事 - “编辑器之神”&quot;&gt;&lt;/a&gt;1. 故事 - “编辑器之神”&lt;/h3&gt;&lt;p&gt;为什么&lt;code&gt;Vim&lt;/code&gt;被称为编辑器之神？话说啊，远古时候，有两大神仙，地上很多猿类大多分成两派，一部分仰慕&lt;code&gt;Vim&lt;/code&gt;大神，另一部分崇拜&lt;code&gt;Emacs&lt;/code&gt;大仙，这两派互相挖苦比较，只相信自己的信仰之神是最强大的！&lt;del&gt;我呢，暂时站&lt;code&gt;Vim&lt;/code&gt;神的，不排除以后叛变啦！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;好了，正经说话吧！高校里教学c语言时，应该是用的&lt;code&gt;VC++6.0&lt;/code&gt; or &lt;code&gt;VS2010&lt;/code&gt;，这两个是编辑器嘛？当然，不是的！他们都是集成开发环境（&lt;code&gt;IDE&lt;/code&gt;，&lt;code&gt;Integrated Development Environment&lt;/code&gt;）,而&lt;code&gt;Vim&lt;/code&gt;才是编辑器，与&lt;code&gt;vim&lt;/code&gt;一起称作编辑器还有啥子呢？比如，&lt;code&gt;Emacs&lt;/code&gt;（Vim在这个世界上的最强大对手）,&lt;code&gt;VS code&lt;/code&gt;（Microsoft推出的开源编辑器，是我最近使用的最频繁的编辑器，可以说面对学习曲线陡峭的Vim来说，&lt;code&gt;VS code&lt;/code&gt;是最容易上手的编辑器，我现在在写的这篇blog就是用&lt;code&gt;VS code&lt;/code&gt;写的，插件十分丰富，除了由于GUI界面的存在，可能在内存上稍高于&lt;code&gt;Vim&lt;/code&gt;，但比起鬼畜的&lt;code&gt;Atom&lt;/code&gt;来说，那是好到不知道哪里去了的存在）,&lt;code&gt;Atom&lt;/code&gt;（Google推出的开源编辑器，同样因为开源的原因，插件十分丰富）,&lt;code&gt;Sublime Text&lt;/code&gt;（前端engineer一定经历过的编辑器，插件丰富，性能极优）等等……&lt;/p&gt;
&lt;p&gt;好了，你现在肯定会问我，为啥我这次blog只介绍Vim呢？因为，Vim难学啊！这里有一张网上嘲讽几大编辑器的学习曲线～&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/主流編輯器學習曲線圖.jpg&quot; alt=&quot;vim-line&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-学习Vim能给你带来什么？&quot;&gt;&lt;a href=&quot;#2-学习Vim能给你带来什么？&quot; class=&quot;headerlink&quot; title=&quot;2. 学习Vim能给你带来什么？&quot;&gt;&lt;/a&gt;2. 学习Vim能给你带来什么？&lt;/h3&gt;&lt;p&gt;从图上我们能看出，vim（vi）的学习曲线入门是十分陡峭的，Emacs的略显鬼畜2333～！那，学习Vim对于我来说，到底有什么什么好处呢？我在刚刚学习Vim时，也是有抱着这个疑惑的，后来总是强迫自己去学+在网上了解Vim，我觉得学习对你可能会有这些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;熟悉命令行工具：Vim是在终端（Terminal）上运行的编辑器，学习Vim无疑你会在命令行下进行频繁操作，而命令行工具对于程序员来说，是十分重要的！也许大部分同学的开发环境大部分还是Windows，使用命令行工具的机会很少！但是以后科研or工作，开发平台就不一定是Windows了，也不一定会有带图形界面的开发工具给你使用。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你科研跑TensorFlow，进行深度学习方面的科研，大概率会需要在linux上跑；做机器学习离不开Linux～我最近在做计算机视觉（Computer Vision）的研究，小方向现在做的是对机械臂进行视觉定位，然而这个机械臂的ROS操作工具，就必须在Linux下进行~～macOS&amp;amp;Windows都没提供~~&lt;/li&gt;
&lt;li&gt;你是EE爱好者（robot开发方向的爱好者），而ROS (Robot Operating System, 机器人操作系统) 恰恰只提供给你Linux的开发工具（且只保证Ubuntu（Linux的一个发行版）能够完美兼容），你作为机器人方向开发者，无法避免命令行工具的使用&lt;/li&gt;
&lt;li&gt;除了科研界，工程界对于命令行工具的使用不要太多！各大互联网的大厂的每一个开发岗offer，无论你是c/c++/java/python/c#/前端/运维等，哪个岗位要求都会有这么一句“熟悉使用命令行操作工具”or“熟悉shell脚本语言编程”，可以说，使用命令行工具是一位合格的计算机专业大学生应该具有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vim具有其他编辑器不具有的与生俱来的特殊功能，比如轻松运用SSH（SSH指：. Secure Shell（缩写：SSH），即“安全壳协议”，一项计算机上的安全协议）；Vim内存占用很低，对于开发配置要求极低，比起具有图形界面的VS code，Atom，Sublime来说，可以说能开机的电脑都能顺溜地跑Vim～！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后一个：Vim能帮助乌干达的贫苦儿童，这是个梗2333～！不过，认真讲哦～你用Vim写代码，是在帮助世界上的其他小孩子呢！还有什么理由，不好好写代码233～！&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/fuujiro/pictures/master/vim操作/4170551-f560a9916f58202d.jpg&quot; alt=&quot;Uganda&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信前面的大串理由，你一定拒绝不了Vim的诱惑，不如和我一起来学习Vim工具吧～啦啦啦～！&lt;/p&gt;
&lt;h3 id=&quot;3-Vim介绍以及如何入门&quot;&gt;&lt;a href=&quot;#3-Vim介绍以及如何入门&quot; class=&quot;headerlink&quot; title=&quot;3. Vim介绍以及如何入门&quot;&gt;&lt;/a&gt;3. Vim介绍以及如何入门&lt;/h3&gt;&lt;h4 id=&quot;3-1-Vim和Vi的关系&quot;&gt;&lt;a href=&quot;#3-1-Vim和Vi的关系&quot; class=&quot;headerlink&quot; title=&quot;3.1 Vim和Vi的关系&quot;&gt;&lt;/a&gt;3.1 Vim和Vi的关系&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Hexo框架+Apollo主题搭建博客</title>
    <link href="https://blog.fuujiro.com/2018/02/14/%E4%BD%BF%E7%94%A8Hexo%E6%A1%86%E6%9E%B6-Apollo%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://blog.fuujiro.com/2018/02/14/使用Hexo框架-Apollo主题搭建博客/</id>
    <published>2018-02-14T15:49:33.000Z</published>
    <updated>2018-06-12T11:00:36.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>时间过得贼快啊！我一下子就要大二下学期了！想着自己以后大概率就是一名老实的程序员。按着这个程序猿们的习惯啊，一般都会有个自己的博客，也不论是追求技术还是跟风吧，我脑子一热呢，就准备搭一个自己的Blog。</p><p>脑子热的时候是2月11号晚上，然后既然热了，那就行动呗。先google了一下个人博客的主流框架和搭建入门咯。最后还是放弃了Wordpress，选择了Hexo来搭建，原因是Hexo开源，主题选择丰富，emmmm就酱。关于为啥选择apollo主题呢，主要是有天瞎逛时，误入了<a href="https://blog.phoenixlzx.com" target="_blank" rel="noopener">phoenixlzx巨巨的blog</a>，他用的就是Apollo主题。我定睛一看，这就是我想要的<del>滑板鞋</del>主题！</p><p><a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">Apollo</a>主题的<a href="https://github.com/pinggod" target="_blank" rel="noopener">开发者</a>据说是一位92年的小哥哥，开发Apollo的时候在美团前端任职，现在根据他的GitHub主页应该是在Alipay工作了。我选择Apollo主题的原因是因为它风格简约，我觉得浏览时加载体验比博客华丽的外观会重要很多，你想想等加载是很烦躁的一件事（嗯，至少来说我是这样…），何况Apollo还简约得好看一匹，果断Mark。如下图。</p><p><img src="https://cloud.githubusercontent.com/assets/9530963/13026956/08e76eca-d277-11e5-8bfc-2e80cea20a0d.png" alt="hexo-apollo"></p><p>嗯！真的很耐看！清新，简约，Nice！</p><p>既然选择好了框架+主题，就进入正式阶段（以下一切安装代码，在OS X无问题，Windows可能会要稍作修改）。</p><h3 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1. 安装Hexo"></a>1. 安装Hexo</h3><p>因为Hexo是一款基于Node.js的静态博客框架，生成静态网页托管在GitHub。所以我们在安装Hexo前得先装上Node.js和git。</p><h4 id="1-1-安装Node-js"><a href="#1-1-安装Node-js" class="headerlink" title="1.1 安装Node.js"></a>1.1 安装Node.js</h4><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载Node.js</a></li><li><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装Node.js</a></li></ul><h4 id="1-2-安装git"><a href="#1-2-安装git" class="headerlink" title="1.2 安装git"></a>1.2 安装git</h4><ul><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载git</a>（可能会有墙的限制，请翻墙|在网盘or网站CSDN上都可以找到离线包）</li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">安装git</a></li><li><a href="https://git-scm.com/book/zh/v1/起步-初次运行-Git-前的配置" target="_blank" rel="noopener">配置自己的git</a>（重要：别忘了这步）</li></ul><h4 id="1-3-安装Hexo"><a href="#1-3-安装Hexo" class="headerlink" title="1.3 安装Hexo"></a>1.3 安装Hexo</h4><p>因为已经装好了Node.js环境了，所以可以使用npm命令。</p><ol><li>使用npm命令安装Hexo，输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli </span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></li></ol><p>如果收到error，在命令行首加上<code>sudo</code>。</p><ol start="2"><li><p>初始化博客<br>找到你要放置博客的根目录（推荐建立一个文件夹用来放置，<del>强迫症必须不得不这么干</del>），建好了我们就开始初始化，比如我们已经了创建了一个名为blog的文件夹<del>程序员最好不要创造出有中文的路径吧</del>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>常规操作<br>接下来搭个静态界面，看看预期，满足下心脏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog #切到blog文件夹下</span><br><span class="line">$ npm install  </span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ol><p>按照正常操作，这时候命令行会抛出一个链接<code>http://localhost:4000/</code>，你复制这串网址粘贴到浏览器打开，不出错误的话，会看到第一个由Hexo框架搭建的网页。如果这时候，你没看到or失败了，可能需要google一下。</p><p>接着，普及一下Hexo框架的基本操作和作用</p><ol><li>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件</li><li>hexo server (hexo s) 启动本地web服务，用于博客的预览</li><li>hexo deploy (hexo d) 部署博客到远端（比如github平台）</li><li>hexo clean 清除缓存</li></ol><p>你还会用到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;postName&quot; #新建博客的文章</span><br><span class="line">$ hexo new page &quot;pageName&quot; #新建博客的页面</span><br><span class="line">$ hexo g &amp;&amp; hexo d #生成部署</span><br><span class="line">$ hexo s #生成本地预览</span><br></pre></td></tr></table></figure></p><p>我写这篇文章时的本地环境，你可以参考一下（使用<code>hexo -v</code>查看，我使用的是OS X系统搭建）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo: 3.5.0</span><br><span class="line">hexo-cli: 1.0.4</span><br><span class="line">os: Darwin 17.2.0 darwin x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 8.9.4</span><br><span class="line">v8: 6.1.534.50</span><br><span class="line">uv: 1.15.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.25.0</span><br><span class="line">openssl: 1.0.2n</span><br><span class="line">icu: 59.1</span><br><span class="line">unicode: 9.0</span><br><span class="line">cldr: 31.0.1</span><br><span class="line">tz: 2017b</span><br></pre></td></tr></table></figure></p><h3 id="2-apollo主题配置"><a href="#2-apollo主题配置" class="headerlink" title="2. apollo主题配置"></a>2. apollo主题配置</h3><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd Blog </span><br><span class="line">$ npm install</span><br><span class="line">$ npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">$ git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo</span><br></pre></td></tr></table></figure><h4 id="2-2-启用"><a href="#2-2-启用" class="headerlink" title="2.2 启用"></a>2.2 启用</h4><p>修改<code>_config.yml</code>的<code>theme</code>配置项为<code>apollo</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">theme: apollo</span><br><span class="line"></span><br><span class="line">archive_generator:</span><br><span class="line">    per_page: 0</span><br><span class="line">    yearly: false</span><br><span class="line">    monthly: false</span><br><span class="line">    daily: false</span><br></pre></td></tr></table></figure></p><h4 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>浏览器打开<code>http://localhost:4000/</code>，看有没有出现apollo标准样式博客，如果没有成功，请自行Google查错。</p><h4 id="2-4-更新"><a href="#2-4-更新" class="headerlink" title="2.4 更新"></a>2.4 更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/apollo </span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h3 id="3-托管到GitHub-链接个人域名"><a href="#3-托管到GitHub-链接个人域名" class="headerlink" title="3. 托管到GitHub + 链接个人域名"></a>3. 托管到GitHub + 链接个人域名</h3><h4 id="3-1-基本准备"><a href="#3-1-基本准备" class="headerlink" title="3.1 基本准备"></a>3.1 基本准备</h4><ul><li>GitHub账户一个</li><li><p>一个自定义域名（从阿里云，腾讯云等都可以购买，自带解析服务，推荐；当然也可以选择国外网站，不过国内访问速度可能会稍差一点）</p><p>我默认你会基本git和GitHub操作，嗯！如果不会，请移步<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰老师的git教程</a>。</p></li></ul><h4 id="3-2-托管步骤"><a href="#3-2-托管步骤" class="headerlink" title="3.2 托管步骤"></a>3.2 托管步骤</h4><p>我们利用<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>来介绍托管在GitHub的项目。由于<code>GitHub Pages</code>的空间免费稳定，用来做搭建一个博客再好不过了。</p><ul><li><a href="https://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li></ul><p>上面这篇博文详细的介绍了<code>ssh key</code>的获取和链接，介绍了<code>GitHub Pages</code>上面搭建Hexo博客的步骤.</p><p>关键点：</p><h5 id="3-2-1-设置ssh-key"><a href="#3-2-1-设置ssh-key" class="headerlink" title="3.2.1 设置ssh-key"></a>3.2.1 设置ssh-key</h5><ol><li>配置 SSH keys<br> 我们如何让本地 git 项目与远程的 GitHub 建立联系呢？用 SSH keys。</li><li><p>检查 SSH keys的设置<br> 首先我们需要检查电脑上是否已有ssh key：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh 检查本机的ssh密钥</span><br></pre></td></tr></table></figure><p> 如果提示的是<code>No such file or directory</code>，说明你是第一次在本机上使用，需要创建一个。</p></li><li><p>生成新的 SSH Key</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就OK&gt;</span><br></pre></td></tr></table></figure><ul><li>此处的邮箱地址，推荐使用你的GitHub账户邮箱</li><li><p>此处的「-C」的是大写的「C」</p><p>然后系统会要你输入密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Enter passphrase (empty for no passphrase):&lt;输入密码&gt;</span><br><span class="line">$ Enter same passphrase again:&lt;再次输入密码&gt;</span><br></pre></td></tr></table></figure><p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p></li><li>其实没必要设置，完全可以敲两下回车；当然设置也没有关系</li><li>注意：输入密码的时候没有 * 字样的，你直接输入就可以了。（我个人觉得git还可以完善的一个细节）</li></ul></li><li>最后看到这样的界面，就成功设置ssh key了：<br> <img src="https://upload-images.jianshu.io/upload_images/32598-cf2af2bff37b1031.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/544" alt="ssh-key"></li></ol><h5 id="3-2-2-添加ssh-key到GitHub"><a href="#3-2-2-添加ssh-key到GitHub" class="headerlink" title="3.2.2 添加ssh key到GitHub"></a>3.2.2 添加ssh key到GitHub</h5><p>在本机设置 SSH Key 之后，需要添加到 GitHub上，以完成 SSH 链接的设置。</p><ul><li>1、打开本地 id_rsa.pub 文件（如：<code>/Users/fuujiro/.ssh/id_rsa.pub</code>）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</li><li>2、登陆 GitHub 系统。点击右上角的<code>Account Settings</code>—&gt;<code>SSH Public keys</code>—&gt;<code>add another public keys</code></li><li>把你本地生成的密钥复制到里面（<code>key</code>文本框中）， 点击<code>add key</code>就ok了<br><img src="https://upload-images.jianshu.io/upload_images/32598-c8b55d62cc0dbd07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/470" alt="add-ssh-key"></li></ul><h4 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3 测试"></a>3.2.3 测试</h4><p>可以输入下面的命令，看看设置是否成功，<a href="mailto:git@GitHub.com" target="_blank" rel="noopener">git@GitHub.com</a> 的部分不要修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@GitHub.com</span><br></pre></td></tr></table></figure></p><p>按道理会显示下面的反馈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;GitHub.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>输入<code>yes</code>就ok，按道理会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi （你的GitHub名字）! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><p>恭喜你！SSH Key 配置成功！本机已成功连接到 GitHub。</p><ul><li>当然，比较倒霉。如果没按道理，大部分可能是墙的原因，你可能需要<code>ping git@GitHub.com</code>拿d到IP地址，然后在/hosts里添加上这个解析。请自行Google解决这个<code>little issue</code></li><li>一个常见错误：<a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="noopener">GitHub Help - Error Permission denied (publickey)</a></li></ul><h4 id="3-3-将独立域名与-GitHub-Pages-的空间绑定"><a href="#3-3-将独立域名与-GitHub-Pages-的空间绑定" class="headerlink" title="3.3 将独立域名与 GitHub Pages 的空间绑定"></a>3.3 将独立域名与 GitHub Pages 的空间绑定</h4><ol><li><code>DNS</code>设置 or 域名解析<br>我用的腾讯云的控制台，找到域名，点一下右侧的解析按钮即可解决。阿里云买的域名也可以由阿里云解析。这里也可以使用<a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSpod</a>，注册一个账户，即可解析域名了，但应该仅限于解析国内域名。国外的域名，如<code>GoDaddy</code>，请上<code>GoDaddy</code>自行修改DNS。</li><li><p>如何设置DNS<br> <img src="https://mc.qcloudimg.com/static/img/8231080d9d713baf5d4edf4163b23ee0/image.png" alt="DNS设置"><br> 主要有以下几项设置需要填写（以域名fuujiro.com为例）：</p><ul><li>主机记录<ul><li>www：解析后的域名为 <code>www.fuujiro.com</code></li><li>@：直接解析主域名 <code>fuujiro.com</code></li><li><em>：泛解析，匹配其他所有域名 `</em>.fuujiro.com`</li><li>mail：将域名解析为 <code>mail.fuujiro.com</code>，通常用于解析邮箱服务器</li><li>二级域名：如<code>blog.fuujiro.com</code>，填写blog</li><li>手机网站：<code>m.fuujiro.com</code>，填写m</li></ul></li><li>记录类型<ul><li>A：将域名指向云服务器，请选择「A」；</li><li>CNAME：将域名指向另一个域名，请选择「CNAME」；</li><li>MX：建立邮箱请选择「MX」，根据邮箱服务商提供的MX记录填写。</li></ul></li><li><p>记录值：填写需要链接的那个域名，如：<code>fuujiro.github.io</code></p><p>例：如果我们需要把<code>fuujiro.github.io</code>和<code>blog.fuujiro.com</code>链接，主机记录：<code>blog</code>，记录类型：<code>CNAME</code>，记录值：<code>fuujiro.github.io</code>。</p></li></ul></li><li>然后在你的博客根目录下，找到<code>/source</code>文件夹，进入文件夹，创建一个无格式的名为<code>CNAME</code>的文本文件，文件里填好<code>blog.fuujiro.com</code>（你的个人域名）</li><li>测试<br>浏览器打开<code>你的个人域名</code>如<del>blog.fuujiro.com</del>，查看是否加载出页面，如果成功！恭喜你啊，你所有步骤基本完成，尽情地享受你的个人blog，开始码代码吧！頑張って！</li></ol><h3 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h3><p>本来情人节当晚，<del>我就完成了blog的全部搭建</del>我就准备开始写这篇文章了，emmmm也就是昨晚了，结果写着写着就困了，就睡觉去了<del>知道我为什么这么菜了吧我真的很懒</del>。然后今天白天，按着假期规律呗，中午11点多起床，码了几行字，然后<del>吃饭陪我爸聊天，买衣服，陪弟弟放鞭炮</del>在大年三十完成这篇文章的<code>flag</code>就倒了，无情地倒下了！</p><p>不过我没有放弃，继续加油，还是在大年初一，emmmm完结了这篇blog！也谢谢你看到这里，祝你在狗年新年快乐～万事如意！狗年不再出bug！！hahah~</p><p>致谢：</p><ol><li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">令狐葱@前端笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">吴润的知乎专栏：cs专业那些事</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;时间过得贼快啊！我一下子就要大二下学期了！想着自己以后大概率就是一名老实的程序员。按着这个程序猿们的习惯啊，一般都会有个自己的博客，也不论是追求技术还是跟风吧，我脑子一热呢，就准备搭一个自己的Blog。&lt;/p&gt;
&lt;p&gt;脑子热的时候是2月11号晚上，然后既然热了，那就行动呗。先google了一下个人博客的主流框架和搭建入门咯。最后还是放弃了Wordpress，选择了Hexo来搭建，原因是Hexo开源，主题选择丰富，emmmm就酱。关于为啥选择apollo主题呢，主要是有天瞎逛时，误入了&lt;a href=&quot;https://blog.phoenixlzx.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;phoenixlzx巨巨的blog&lt;/a&gt;，他用的就是Apollo主题。我定睛一看，这就是我想要的&lt;del&gt;滑板鞋&lt;/del&gt;主题！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apollo&lt;/a&gt;主题的&lt;a href=&quot;https://github.com/pinggod&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开发者&lt;/a&gt;据说是一位92年的小哥哥，开发Apollo的时候在美团前端任职，现在根据他的GitHub主页应该是在Alipay工作了。我选择Apollo主题的原因是因为它风格简约，我觉得浏览时加载体验比博客华丽的外观会重要很多，你想想等加载是很烦躁的一件事（嗯，至少来说我是这样…），何况Apollo还简约得好看一匹，果断Mark。如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/9530963/13026956/08e76eca-d277-11e5-8bfc-2e80cea20a0d.png&quot; alt=&quot;hexo-apollo&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗯！真的很耐看！清新，简约，Nice！&lt;/p&gt;
&lt;p&gt;既然选择好了框架+主题，就进入正式阶段（以下一切安装代码，在OS X无问题，Windows可能会要稍作修改）。&lt;/p&gt;
&lt;h3 id=&quot;1-安装Hexo&quot;&gt;&lt;a href=&quot;#1-安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Hexo&quot;&gt;&lt;/a&gt;1. 安装Hexo&lt;/h3&gt;&lt;p&gt;因为Hexo是一款基于Node.js的静态博客框架，生成静态网页托管在GitHub。所以我们在安装Hexo前得先装上Node.js和git。&lt;/p&gt;
&lt;h4 id=&quot;1-1-安装Node-js&quot;&gt;&lt;a href=&quot;#1-1-安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;1.1 安装Node.js&quot;&gt;&lt;/a&gt;1.1 安装Node.js&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Markdown简单语法入门</title>
    <link href="https://blog.fuujiro.com/2018/02/14/Markdown%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.fuujiro.com/2018/02/14/Markdown简单语法入门/</id>
    <published>2018-02-14T14:32:42.000Z</published>
    <updated>2018-06-12T11:00:36.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>这是<strong>Cmd Markdown</strong> 的广告，我觉得写的不错，作为学习<code>markdown</code>语法的入门文档最好不过啦~！</p></blockquote><hr><h3 id="原文档"><a href="#原文档" class="headerlink" title="原文档"></a>原文档</h3><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[x] 新增 Todo 列表功能</li><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><blockquote><p>更多Markdown用法，请戳：</p></blockquote><ul><li><a href="https://blog.csdn.net/zdk930519/article/details/54137476" target="_blank" rel="noopener">Markdown中数学公式整理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这是&lt;strong&gt;Cmd Markdown&lt;/strong&gt; 的广告，我觉得写的不错，作为学习&lt;code&gt;markdown&lt;/code&gt;语法的入门文档最好不过啦~！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;原文档&quot;&gt;&lt;a href=&quot;#原文档&quot; class=&quot;headerlink&quot; title=&quot;原文档&quot;&gt;&lt;/a&gt;原文档&lt;/h3&gt;&lt;p&gt;我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，&lt;strong&gt;Cmd Markdown&lt;/strong&gt; 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;整理知识，学习笔记&lt;/li&gt;
&lt;li&gt;发布日记，杂文，所见所想&lt;/li&gt;
&lt;li&gt;撰写发布技术文稿（代码支持）&lt;/li&gt;
&lt;li&gt;撰写发布学术论文（LaTeX 公式支持）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zybuluo.com/static/img/logo.png&quot; alt=&quot;cmd-markdown-logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：&lt;/p&gt;
&lt;h3 id=&quot;Windows-Mac-Linux-全平台客户端&quot;&gt;&lt;a href=&quot;#Windows-Mac-Linux-全平台客户端&quot; class=&quot;headerlink&quot; title=&quot;Windows/Mac/Linux 全平台客户端&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.zybuluo.com/cmd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows/Mac/Linux 全平台客户端&lt;/a&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 &lt;i class=&quot;icon-file&quot;&gt;&lt;/i&gt; &lt;strong&gt;新文稿&lt;/strong&gt; 或者使用快捷键 &lt;code&gt;Ctrl+Alt+N&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
