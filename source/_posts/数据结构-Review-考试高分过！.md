---
title: 数据结构-Review-考试高分过！
date: 2018-04-29 10:42:36
tags:
---

### 前言

复习一下快要课没好好上过的数据结构，唉！要考试噜！得刷一波绩点啦！！！认真复习嗯嗯嗯！大连理工的`数据结构（双语）`教学深度不够呢！并没有介绍啥子算法，但是李培华老师还是很棒的，讲的很有条理~！唉，分成了`电子信息`和`计算机`两种不同的要求，电创班居然是电信要求，不开森！不过数据结构和算法要是想成为`Master`，主要还是看自学的啦！

---

### 目录

1. **线性表**
    1.1 顺序表示和实现
    1.2 链式表示和实现
    1.2.1 `线性链表`
    1.2.2 `循环链表`
    1.2.3 `双向链表`

2. **栈和队列**
    2.1 栈
    2.2 队列

3. **数组**
    3.1 数组的定义
    3.2 数组的顺序表示和实现
    3.3 矩阵的压缩储存
    3.3.1 `稀疏矩阵`

4. **树**
    4.1 二叉树
    4.2 遍历二叉树
    4.3 树和森林
    4.4 赫夫曼树

5. **图**
    5.1 图的定义
    5.2 图的储存结构
    5.2.1 `邻接表`
    5.2.2 `十字链表`
    5.3 图的遍历
    5.3.1 `深度优先搜索`
    5.3.2 `广度优先搜索`
    5.4 图的连通性
    5.4.1 `生成树`
    5.4.2 `最小生成树`
    5.5 拓扑排序
    5.6 最短路径

6. **查找**
    6.1 静态查找
    6.2 动态查找
    6.2.1 `二叉排序树`
    6.3 哈希表

7. **内部排序**
    7.1 插入排序
    7.1.1 `直接插入排序`
    7.1.2 `希尔排序`
    7.2 快速排序
    7.3 选择排序
    7.4 归并排序

---

### 1. 线性表

> 线性表`Linear_list`是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。

#### 1.1 顺序表示和实现

> 线性表的顺序表示`Sequential List`指的是用一组地址连续的储存单元依次储存线性表的数据元素。`顺序储存结构`是一种随机存取的储存结构。通常用`数组`来描述顺序储存结构。

C语言用动态分配的一维数组，来描述线性表：
~~~
 #define LIST_INIT_SIZE 100 //线性表储存空间的初始分配量
 #define LISTINCREMENT 10 //线性表的分配量
typedef int ElemType;
typedef struct {
    ElemType *elem;  // 储存空间的基地址
    int length;  //当前线性表的长度
    int listsize; //当前分配的储存容量
}SqList;
~~~

更多有关线性表的基本操作，请戳——>[线性表与13个基本操作的实现](https://blog.csdn.net/bruthyu/article/details/52645510)

#### 1.2 链式表示和实现

> 链式储存结构`Linked List`与顺序储存结构`Sequential List`的不同：顺序储存结构的特点是逻辑关系上两个相邻元素在物理位置上也相同，这样随机存取任意元素很快很直观，缺点是需要移动大量其他元素。而链式结构，它不要求逻辑上相邻的元素在物理位置上相邻，因此它存取元素不需要移动其他元素，但是对于查找元素有心无力。

##### 1.2.1 `线性链表`

> 可以理解为单向链表`Singly Linked List`，单向链表是非随机存取结构

一些常用的方法：
* 添加元素（s是指向待添加节点的指针）
    ~~~
    s->next = p->next;
    p->next = s;
    ~~~
* 删除元素（a,b,c是链表中相连的3个结点，b是待删除的结点，现在p是指向a结点的指针）
    ~~~
    p->next = p->next->next;
    ~~~

用结构体实现链表结点：
~~~
//线性表的单链表储存结构
struct Node {
    int data; //数据域
    struct Node *next; //指针域
};
~~~

更多链表基本实现和操作，请戳：

* [C语言单向链表的实现](https://blog.csdn.net/21aspnet/article/details/160019)
* [链表的基本使用一（构建链表）](https://blog.csdn.net/lan74__/article/details/53819849)
* [数据结构：链表(linked-list)](https://blog.csdn.net/juanqinyang/article/details/51351619)

##### 1.2.2 `循环链表`

1. 循环单链表特点： 
链表中最后一个结点的指针域不再是结束标志，而是指向整个链表的第一个结点，从而使链表形成一个环。和单链表相同，循环单链表也有带头结点和不带头结点两种。带头结点的循环单链表实现插入和删除操作较为方便，且更加适用。

2. 单链表与循环单链表比较： 
循环单链表可以从尾到头，而单链表不能从尾到头。因此处理的数据序列具有环形结构特点时，适合采用循环单链表。

3. 带头结点的循环单链表和带头结点的单链表比较： 
① 在初始化函数中，把语句`head->next=NULL`改为`head->next = head`，即形成一个环 
② 在其他函数中，循环判断条件`p->next!=NULL`和`p->next->next!=NULL`中的NULL改成头指针`head`。

##### 1.2.3 `双向链表`

1. 双向链表特点： 
    每个节点除了有后继指针域还有一个前驱指针域。

2. 双向链表的分类： 
    双向链表有：带头结点和不带头结点的双向链表（但是带头结点的双向链表更为常用）。也有循环和非循环之分，循环结构的双向链表更为常用。因此下面讨论的是带头结点的循环双链表。

3. 双向循环链表结点的结构体定义
    ~~~
    //线性表的双向链表储存结构
    struct DuLNode {
        Elemtype data; //数据域
        struct DuLNode *prior; //前驱结点
        struct DuLNode *next;  //后继结点
    }DuLNode， *DuLinklist;
    ~~~
    **备注**：data域、next域、prior域。其中data域是数据域，next域为指向后继结点的指针域，prior域为指向前驱结点的指针域。

4. 双向链表的优点：
    在单链中查找当前结点的后继结点并不困难，可以通过当前结点的next指针进行，但要查找当前结点的前驱结点，就要从头指针head开始重新进行。对于一个要频繁进行当前结点的后继结点和前驱结点的应用来说，使用双向链表很有效。

5. 双向循环链表的实现
    在双向链表中，有如下指针关系：设指针p指向双向循环链表中的第i个位置，则`p->next`指向i+1个结点。`p->next->prior`仍指向第i个结点，即`p->next->prior==p`;同样`p->prior`指向第i-1个结点，`p->prior->next`仍指向第i个结点，即`p->prior->next==p`;双向循环链表关系算法可以方便算法设计。

更多循环链表和双向链表的知识，请戳：
* [数据结构——循环单链表和双向链表](https://blog.csdn.net/xiaofei__/article/details/50984255)

* [数据结构 | 双向链表简单实现及图示](http://www.cnblogs.com/hughdong/p/6785391.html) -> *recommend*！

### 2. 栈和队列

从数据结构上看，栈和队列也是线性表。不过他们是操作受限的线性表，因此，称它们为限定性的数据结构。

#### 2.1 栈

栈是限定仅在表尾进行插入和删除的线性表。对于栈，表尾称为`栈顶`，相应地，表头称为`栈底`。不含元素的空表称为`空栈`。栈是一种后进先出（last in first out, LIFO）结构。



